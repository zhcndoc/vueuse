const packageNames = [["/shared/createglobalstate/", { "url": "/shared/createGlobalState/", "hash": "createGlobalState" }], ["/shared/createinjectionstate/", { "url": "/shared/createInjectionState/", "hash": "createInjectionState" }], ["/shared/createsharedcomposable/", { "url": "/shared/createSharedComposable/", "hash": "createSharedComposable" }], ["/shared/injectlocal/", { "url": "/shared/injectLocal/", "hash": "injectLocal" }], ["/shared/providelocal/", { "url": "/shared/provideLocal/", "hash": "provideLocal" }], ["/core/useasyncstate/", { "url": "/core/useAsyncState/", "hash": "useAsyncState" }], ["/core/usedebouncedrefhistory/", { "url": "/core/useDebouncedRefHistory/", "hash": "useDebouncedRefHistory" }], ["/shared/uselastchanged/", { "url": "/shared/useLastChanged/", "hash": "useLastChanged" }], ["/core/uselocalstorage/", { "url": "/core/useLocalStorage/", "hash": "useLocalStorage" }], ["/core/usemanualrefhistory/", { "url": "/core/useManualRefHistory/", "hash": "useManualRefHistory" }], ["/core/userefhistory/", { "url": "/core/useRefHistory/", "hash": "useRefHistory" }], ["/core/usesessionstorage/", { "url": "/core/useSessionStorage/", "hash": "useSessionStorage" }], ["/core/usestorage/", { "url": "/core/useStorage/", "hash": "useStorage" }], ["/core/usestorageasync/", { "url": "/core/useStorageAsync/", "hash": "useStorageAsync" }], ["/core/usethrottledrefhistory/", { "url": "/core/useThrottledRefHistory/", "hash": "useThrottledRefHistory" }], ["/core/useactiveelement/", { "url": "/core/useActiveElement/", "hash": "useActiveElement" }], ["/core/usedocumentvisibility/", { "url": "/core/useDocumentVisibility/", "hash": "useDocumentVisibility" }], ["/core/usedraggable/", { "url": "/core/useDraggable/", "hash": "useDraggable" }], ["/core/usedropzone/", { "url": "/core/useDropZone/", "hash": "useDropZone" }], ["/core/useelementbounding/", { "url": "/core/useElementBounding/", "hash": "useElementBounding" }], ["/core/useelementsize/", { "url": "/core/useElementSize/", "hash": "useElementSize" }], ["/core/useelementvisibility/", { "url": "/core/useElementVisibility/", "hash": "useElementVisibility" }], ["/core/useintersectionobserver/", { "url": "/core/useIntersectionObserver/", "hash": "useIntersectionObserver" }], ["/core/usemouseinelement/", { "url": "/core/useMouseInElement/", "hash": "useMouseInElement" }], ["/core/usemutationobserver/", { "url": "/core/useMutationObserver/", "hash": "useMutationObserver" }], ["/core/useparentelement/", { "url": "/core/useParentElement/", "hash": "useParentElement" }], ["/core/useresizeobserver/", { "url": "/core/useResizeObserver/", "hash": "useResizeObserver" }], ["/core/usewindowfocus/", { "url": "/core/useWindowFocus/", "hash": "useWindowFocus" }], ["/core/usewindowscroll/", { "url": "/core/useWindowScroll/", "hash": "useWindowScroll" }], ["/core/usewindowsize/", { "url": "/core/useWindowSize/", "hash": "useWindowSize" }], ["/core/usebluetooth/", { "url": "/core/useBluetooth/", "hash": "useBluetooth" }], ["/core/usebreakpoints/", { "url": "/core/useBreakpoints/", "hash": "useBreakpoints" }], ["/core/usebroadcastchannel/", { "url": "/core/useBroadcastChannel/", "hash": "useBroadcastChannel" }], ["/core/usebrowserlocation/", { "url": "/core/useBrowserLocation/", "hash": "useBrowserLocation" }], ["/core/useclipboard/", { "url": "/core/useClipboard/", "hash": "useClipboard" }], ["/core/useclipboarditems/", { "url": "/core/useClipboardItems/", "hash": "useClipboardItems" }], ["/core/usecolormode/", { "url": "/core/useColorMode/", "hash": "useColorMode" }], ["/core/usecssvar/", { "url": "/core/useCssVar/", "hash": "useCssVar" }], ["/core/usedark/", { "url": "/core/useDark/", "hash": "useDark" }], ["/core/useeventlistener/", { "url": "/core/useEventListener/", "hash": "useEventListener" }], ["/core/useeyedropper/", { "url": "/core/useEyeDropper/", "hash": "useEyeDropper" }], ["/core/usefavicon/", { "url": "/core/useFavicon/", "hash": "useFavicon" }], ["/core/usefiledialog/", { "url": "/core/useFileDialog/", "hash": "useFileDialog" }], ["/core/usefilesystemaccess/", { "url": "/core/useFileSystemAccess/", "hash": "useFileSystemAccess" }], ["/core/usefullscreen/", { "url": "/core/useFullscreen/", "hash": "useFullscreen" }], ["/core/usegamepad/", { "url": "/core/useGamepad/", "hash": "useGamepad" }], ["/core/useimage/", { "url": "/core/useImage/", "hash": "useImage" }], ["/core/usemediacontrols/", { "url": "/core/useMediaControls/", "hash": "useMediaControls" }], ["/core/usemediaquery/", { "url": "/core/useMediaQuery/", "hash": "useMediaQuery" }], ["/core/usememory/", { "url": "/core/useMemory/", "hash": "useMemory" }], ["/core/useobjecturl/", { "url": "/core/useObjectUrl/", "hash": "useObjectUrl" }], ["/core/useperformanceobserver/", { "url": "/core/usePerformanceObserver/", "hash": "usePerformanceObserver" }], ["/core/usepermission/", { "url": "/core/usePermission/", "hash": "usePermission" }], ["/core/usepreferredcolorscheme/", { "url": "/core/usePreferredColorScheme/", "hash": "usePreferredColorScheme" }], ["/core/usepreferredcontrast/", { "url": "/core/usePreferredContrast/", "hash": "usePreferredContrast" }], ["/core/usepreferreddark/", { "url": "/core/usePreferredDark/", "hash": "usePreferredDark" }], ["/core/usepreferredlanguages/", { "url": "/core/usePreferredLanguages/", "hash": "usePreferredLanguages" }], ["/core/usepreferredreducedmotion/", { "url": "/core/usePreferredReducedMotion/", "hash": "usePreferredReducedMotion" }], ["/core/usepreferredreducedtransparency/", { "url": "/core/usePreferredReducedTransparency/", "hash": "usePreferredReducedTransparency" }], ["/core/usescreenorientation/", { "url": "/core/useScreenOrientation/", "hash": "useScreenOrientation" }], ["/core/usescreensafearea/", { "url": "/core/useScreenSafeArea/", "hash": "useScreenSafeArea" }], ["/core/usescripttag/", { "url": "/core/useScriptTag/", "hash": "useScriptTag" }], ["/core/useshare/", { "url": "/core/useShare/", "hash": "useShare" }], ["/core/usessrwidth/", { "url": "/core/useSSRWidth/", "hash": "useSSRWidth" }], ["/core/usestyletag/", { "url": "/core/useStyleTag/", "hash": "useStyleTag" }], ["/core/usetextareaautosize/", { "url": "/core/useTextareaAutosize/", "hash": "useTextareaAutosize" }], ["/core/usetextdirection/", { "url": "/core/useTextDirection/", "hash": "useTextDirection" }], ["/core/usetitle/", { "url": "/core/useTitle/", "hash": "useTitle" }], ["/core/useurlsearchparams/", { "url": "/core/useUrlSearchParams/", "hash": "useUrlSearchParams" }], ["/core/usevibrate/", { "url": "/core/useVibrate/", "hash": "useVibrate" }], ["/core/usewakelock/", { "url": "/core/useWakeLock/", "hash": "useWakeLock" }], ["/core/usewebnotification/", { "url": "/core/useWebNotification/", "hash": "useWebNotification" }], ["/core/usewebworker/", { "url": "/core/useWebWorker/", "hash": "useWebWorker" }], ["/core/usewebworkerfn/", { "url": "/core/useWebWorkerFn/", "hash": "useWebWorkerFn" }], ["/core/onclickoutside/", { "url": "/core/onClickOutside/", "hash": "onClickOutside" }], ["/core/onelementremoval/", { "url": "/core/onElementRemoval/", "hash": "onElementRemoval" }], ["/core/onkeystroke/", { "url": "/core/onKeyStroke/", "hash": "onKeyStroke" }], ["/core/onlongpress/", { "url": "/core/onLongPress/", "hash": "onLongPress" }], ["/core/onstarttyping/", { "url": "/core/onStartTyping/", "hash": "onStartTyping" }], ["/core/usebattery/", { "url": "/core/useBattery/", "hash": "useBattery" }], ["/core/usedevicemotion/", { "url": "/core/useDeviceMotion/", "hash": "useDeviceMotion" }], ["/core/usedeviceorientation/", { "url": "/core/useDeviceOrientation/", "hash": "useDeviceOrientation" }], ["/core/usedevicepixelratio/", { "url": "/core/useDevicePixelRatio/", "hash": "useDevicePixelRatio" }], ["/core/usedeviceslist/", { "url": "/core/useDevicesList/", "hash": "useDevicesList" }], ["/core/usedisplaymedia/", { "url": "/core/useDisplayMedia/", "hash": "useDisplayMedia" }], ["/core/useelementbypoint/", { "url": "/core/useElementByPoint/", "hash": "useElementByPoint" }], ["/core/useelementhover/", { "url": "/core/useElementHover/", "hash": "useElementHover" }], ["/core/usefocus/", { "url": "/core/useFocus/", "hash": "useFocus" }], ["/core/usefocuswithin/", { "url": "/core/useFocusWithin/", "hash": "useFocusWithin" }], ["/core/usefps/", { "url": "/core/useFps/", "hash": "useFps" }], ["/core/usegeolocation/", { "url": "/core/useGeolocation/", "hash": "useGeolocation" }], ["/core/useidle/", { "url": "/core/useIdle/", "hash": "useIdle" }], ["/core/useinfinitescroll/", { "url": "/core/useInfiniteScroll/", "hash": "useInfiniteScroll" }], ["/core/usekeymodifier/", { "url": "/core/useKeyModifier/", "hash": "useKeyModifier" }], ["/core/usemagickeys/", { "url": "/core/useMagicKeys/", "hash": "useMagicKeys" }], ["/core/usemouse/", { "url": "/core/useMouse/", "hash": "useMouse" }], ["/core/usemousepressed/", { "url": "/core/useMousePressed/", "hash": "useMousePressed" }], ["/core/usenavigatorlanguage/", { "url": "/core/useNavigatorLanguage/", "hash": "useNavigatorLanguage" }], ["/core/usenetwork/", { "url": "/core/useNetwork/", "hash": "useNetwork" }], ["/core/useonline/", { "url": "/core/useOnline/", "hash": "useOnline" }], ["/core/usepageleave/", { "url": "/core/usePageLeave/", "hash": "usePageLeave" }], ["/core/useparallax/", { "url": "/core/useParallax/", "hash": "useParallax" }], ["/core/usepointer/", { "url": "/core/usePointer/", "hash": "usePointer" }], ["/core/usepointerlock/", { "url": "/core/usePointerLock/", "hash": "usePointerLock" }], ["/core/usepointerswipe/", { "url": "/core/usePointerSwipe/", "hash": "usePointerSwipe" }], ["/core/usescroll/", { "url": "/core/useScroll/", "hash": "useScroll" }], ["/core/usescrolllock/", { "url": "/core/useScrollLock/", "hash": "useScrollLock" }], ["/core/usespeechrecognition/", { "url": "/core/useSpeechRecognition/", "hash": "useSpeechRecognition" }], ["/core/usespeechsynthesis/", { "url": "/core/useSpeechSynthesis/", "hash": "useSpeechSynthesis" }], ["/core/useswipe/", { "url": "/core/useSwipe/", "hash": "useSwipe" }], ["/core/usetextselection/", { "url": "/core/useTextSelection/", "hash": "useTextSelection" }], ["/core/useusermedia/", { "url": "/core/useUserMedia/", "hash": "useUserMedia" }], ["/core/useeventsource/", { "url": "/core/useEventSource/", "hash": "useEventSource" }], ["/core/usefetch/", { "url": "/core/useFetch/", "hash": "useFetch" }], ["/core/usewebsocket/", { "url": "/core/useWebSocket/", "hash": "useWebSocket" }], ["/core/useanimate/", { "url": "/core/useAnimate/", "hash": "useAnimate" }], ["/shared/useinterval/", { "url": "/shared/useInterval/", "hash": "useInterval" }], ["/shared/useintervalfn/", { "url": "/shared/useIntervalFn/", "hash": "useIntervalFn" }], ["/core/usenow/", { "url": "/core/useNow/", "hash": "useNow" }], ["/core/useraffn/", { "url": "/core/useRafFn/", "hash": "useRafFn" }], ["/shared/usetimeout/", { "url": "/shared/useTimeout/", "hash": "useTimeout" }], ["/shared/usetimeoutfn/", { "url": "/shared/useTimeoutFn/", "hash": "useTimeoutFn" }], ["/core/usetimestamp/", { "url": "/core/useTimestamp/", "hash": "useTimestamp" }], ["/core/usetransition/", { "url": "/core/useTransition/", "hash": "useTransition" }], ["/core/computedinject/", { "url": "/core/computedInject/", "hash": "computedInject" }], ["/core/createreusabletemplate/", { "url": "/core/createReusableTemplate/", "hash": "createReusableTemplate" }], ["/core/createtemplatepromise/", { "url": "/core/createTemplatePromise/", "hash": "createTemplatePromise" }], ["/core/templateref/", { "url": "/core/templateRef/", "hash": "templateRef" }], ["/shared/tryonbeforemount/", { "url": "/shared/tryOnBeforeMount/", "hash": "tryOnBeforeMount" }], ["/shared/tryonbeforeunmount/", { "url": "/shared/tryOnBeforeUnmount/", "hash": "tryOnBeforeUnmount" }], ["/shared/tryonmounted/", { "url": "/shared/tryOnMounted/", "hash": "tryOnMounted" }], ["/shared/tryonscopedispose/", { "url": "/shared/tryOnScopeDispose/", "hash": "tryOnScopeDispose" }], ["/shared/tryonunmounted/", { "url": "/shared/tryOnUnmounted/", "hash": "tryOnUnmounted" }], ["/core/unrefelement/", { "url": "/core/unrefElement/", "hash": "unrefElement" }], ["/core/usecurrentelement/", { "url": "/core/useCurrentElement/", "hash": "useCurrentElement" }], ["/core/usemounted/", { "url": "/core/useMounted/", "hash": "useMounted" }], ["/core/usetemplaterefslist/", { "url": "/core/useTemplateRefsList/", "hash": "useTemplateRefsList" }], ["/core/usevirtuallist/", { "url": "/core/useVirtualList/", "hash": "useVirtualList" }], ["/core/usevmodel/", { "url": "/core/useVModel/", "hash": "useVModel" }], ["/core/usevmodels/", { "url": "/core/useVModels/", "hash": "useVModels" }], ["/shared/until/", { "url": "/shared/until/", "hash": "until" }], ["/shared/watcharray/", { "url": "/shared/watchArray/", "hash": "watchArray" }], ["/shared/watchatmost/", { "url": "/shared/watchAtMost/", "hash": "watchAtMost" }], ["/shared/watchdebounced/", { "url": "/shared/watchDebounced/", "hash": "watchDebounced" }], ["/shared/watchdeep/", { "url": "/shared/watchDeep/", "hash": "watchDeep" }], ["/shared/watchignorable/", { "url": "/shared/watchIgnorable/", "hash": "watchIgnorable" }], ["/shared/watchimmediate/", { "url": "/shared/watchImmediate/", "hash": "watchImmediate" }], ["/shared/watchonce/", { "url": "/shared/watchOnce/", "hash": "watchOnce" }], ["/shared/watchpausable/", { "url": "/shared/watchPausable/", "hash": "watchPausable" }], ["/shared/watchthrottled/", { "url": "/shared/watchThrottled/", "hash": "watchThrottled" }], ["/shared/watchtriggerable/", { "url": "/shared/watchTriggerable/", "hash": "watchTriggerable" }], ["/shared/watchwithfilter/", { "url": "/shared/watchWithFilter/", "hash": "watchWithFilter" }], ["/shared/whenever/", { "url": "/shared/whenever/", "hash": "whenever" }], ["/core/computedasync/", { "url": "/core/computedAsync/", "hash": "computedAsync" }], ["/shared/computedeager/", { "url": "/shared/computedEager/", "hash": "computedEager" }], ["/shared/computedwithcontrol/", { "url": "/shared/computedWithControl/", "hash": "computedWithControl" }], ["/shared/createref/", { "url": "/shared/createRef/", "hash": "createRef" }], ["/shared/extendref/", { "url": "/shared/extendRef/", "hash": "extendRef" }], ["/shared/reactify/", { "url": "/shared/reactify/", "hash": "reactify" }], ["/shared/reactifyobject/", { "url": "/shared/reactifyObject/", "hash": "reactifyObject" }], ["/shared/reactivecomputed/", { "url": "/shared/reactiveComputed/", "hash": "reactiveComputed" }], ["/shared/reactiveomit/", { "url": "/shared/reactiveOmit/", "hash": "reactiveOmit" }], ["/shared/reactivepick/", { "url": "/shared/reactivePick/", "hash": "reactivePick" }], ["/shared/refautoreset/", { "url": "/shared/refAutoReset/", "hash": "refAutoReset" }], ["/shared/refdebounced/", { "url": "/shared/refDebounced/", "hash": "refDebounced" }], ["/shared/refdefault/", { "url": "/shared/refDefault/", "hash": "refDefault" }], ["/shared/refmanualreset/", { "url": "/shared/refManualReset/", "hash": "refManualReset" }], ["/shared/refthrottled/", { "url": "/shared/refThrottled/", "hash": "refThrottled" }], ["/shared/refwithcontrol/", { "url": "/shared/refWithControl/", "hash": "refWithControl" }], ["/shared/syncref/", { "url": "/shared/syncRef/", "hash": "syncRef" }], ["/shared/syncrefs/", { "url": "/shared/syncRefs/", "hash": "syncRefs" }], ["/shared/toreactive/", { "url": "/shared/toReactive/", "hash": "toReactive" }], ["/shared/toref/", { "url": "/shared/toRef/", "hash": "toRef" }], ["/shared/torefs/", { "url": "/shared/toRefs/", "hash": "toRefs" }], ["/shared/usearraydifference/", { "url": "/shared/useArrayDifference/", "hash": "useArrayDifference" }], ["/shared/usearrayevery/", { "url": "/shared/useArrayEvery/", "hash": "useArrayEvery" }], ["/shared/usearrayfilter/", { "url": "/shared/useArrayFilter/", "hash": "useArrayFilter" }], ["/shared/usearrayfind/", { "url": "/shared/useArrayFind/", "hash": "useArrayFind" }], ["/shared/usearrayfindindex/", { "url": "/shared/useArrayFindIndex/", "hash": "useArrayFindIndex" }], ["/shared/usearrayfindlast/", { "url": "/shared/useArrayFindLast/", "hash": "useArrayFindLast" }], ["/shared/usearrayincludes/", { "url": "/shared/useArrayIncludes/", "hash": "useArrayIncludes" }], ["/shared/usearrayjoin/", { "url": "/shared/useArrayJoin/", "hash": "useArrayJoin" }], ["/shared/usearraymap/", { "url": "/shared/useArrayMap/", "hash": "useArrayMap" }], ["/shared/usearrayreduce/", { "url": "/shared/useArrayReduce/", "hash": "useArrayReduce" }], ["/shared/usearraysome/", { "url": "/shared/useArraySome/", "hash": "useArraySome" }], ["/shared/usearrayunique/", { "url": "/shared/useArrayUnique/", "hash": "useArrayUnique" }], ["/core/usesorted/", { "url": "/core/useSorted/", "hash": "useSorted" }], ["/core/usecountdown/", { "url": "/core/useCountdown/", "hash": "useCountdown" }], ["/shared/usedateformat/", { "url": "/shared/useDateFormat/", "hash": "useDateFormat" }], ["/core/usetimeago/", { "url": "/core/useTimeAgo/", "hash": "useTimeAgo" }], ["/core/usetimeagointl/", { "url": "/core/useTimeAgoIntl/", "hash": "useTimeAgoIntl" }], ["/shared/createeventhook/", { "url": "/shared/createEventHook/", "hash": "createEventHook" }], ["/core/createunreffn/", { "url": "/core/createUnrefFn/", "hash": "createUnrefFn" }], ["/shared/get/", { "url": "/shared/get/", "hash": "get" }], ["/shared/isdefined/", { "url": "/shared/isDefined/", "hash": "isDefined" }], ["/shared/makedestructurable/", { "url": "/shared/makeDestructurable/", "hash": "makeDestructurable" }], ["/shared/set/", { "url": "/shared/set/", "hash": "set" }], ["/core/useasyncqueue/", { "url": "/core/useAsyncQueue/", "hash": "useAsyncQueue" }], ["/core/usebase64/", { "url": "/core/useBase64/", "hash": "useBase64" }], ["/core/usecached/", { "url": "/core/useCached/", "hash": "useCached" }], ["/core/usecloned/", { "url": "/core/useCloned/", "hash": "useCloned" }], ["/core/useconfirmdialog/", { "url": "/core/useConfirmDialog/", "hash": "useConfirmDialog" }], ["/shared/usecounter/", { "url": "/shared/useCounter/", "hash": "useCounter" }], ["/core/usecyclelist/", { "url": "/core/useCycleList/", "hash": "useCycleList" }], ["/shared/usedebouncefn/", { "url": "/shared/useDebounceFn/", "hash": "useDebounceFn" }], ["/core/useeventbus/", { "url": "/core/useEventBus/", "hash": "useEventBus" }], ["/core/usememoize/", { "url": "/core/useMemoize/", "hash": "useMemoize" }], ["/core/useoffsetpagination/", { "url": "/core/useOffsetPagination/", "hash": "useOffsetPagination" }], ["/core/useprevious/", { "url": "/core/usePrevious/", "hash": "usePrevious" }], ["/core/usestepper/", { "url": "/core/useStepper/", "hash": "useStepper" }], ["/core/usesupported/", { "url": "/core/useSupported/", "hash": "useSupported" }], ["/shared/usethrottlefn/", { "url": "/shared/useThrottleFn/", "hash": "useThrottleFn" }], ["/core/usetimeoutpoll/", { "url": "/core/useTimeoutPoll/", "hash": "useTimeoutPoll" }], ["/shared/usetoggle/", { "url": "/shared/useToggle/", "hash": "useToggle" }], ["/shared/usetonumber/", { "url": "/shared/useToNumber/", "hash": "useToNumber" }], ["/shared/usetostring/", { "url": "/shared/useToString/", "hash": "useToString" }], ["/electron/useipcrenderer/", { "url": "/electron/useIpcRenderer/", "hash": "useIpcRenderer" }], ["/electron/useipcrendererinvoke/", { "url": "/electron/useIpcRendererInvoke/", "hash": "useIpcRendererInvoke" }], ["/electron/useipcrendereron/", { "url": "/electron/useIpcRendererOn/", "hash": "useIpcRendererOn" }], ["/electron/usezoomfactor/", { "url": "/electron/useZoomFactor/", "hash": "useZoomFactor" }], ["/electron/usezoomlevel/", { "url": "/electron/useZoomLevel/", "hash": "useZoomLevel" }], ["/firebase/useauth/", { "url": "/firebase/useAuth/", "hash": "useAuth" }], ["/firebase/usefirestore/", { "url": "/firebase/useFirestore/", "hash": "useFirestore" }], ["/firebase/usertdb/", { "url": "/firebase/useRTDB/", "hash": "useRTDB" }], ["/integrations/useasyncvalidator/", { "url": "/integrations/useAsyncValidator/", "hash": "useAsyncValidator" }], ["/integrations/useaxios/", { "url": "/integrations/useAxios/", "hash": "useAxios" }], ["/integrations/usechangecase/", { "url": "/integrations/useChangeCase/", "hash": "useChangeCase" }], ["/integrations/usecookies/", { "url": "/integrations/useCookies/", "hash": "useCookies" }], ["/integrations/usedrauu/", { "url": "/integrations/useDrauu/", "hash": "useDrauu" }], ["/integrations/usefocustrap/", { "url": "/integrations/useFocusTrap/", "hash": "useFocusTrap" }], ["/integrations/usefuse/", { "url": "/integrations/useFuse/", "hash": "useFuse" }], ["/integrations/useidbkeyval/", { "url": "/integrations/useIDBKeyval/", "hash": "useIDBKeyval" }], ["/integrations/usejwt/", { "url": "/integrations/useJwt/", "hash": "useJwt" }], ["/integrations/usenprogress/", { "url": "/integrations/useNProgress/", "hash": "useNProgress" }], ["/integrations/useqrcode/", { "url": "/integrations/useQRCode/", "hash": "useQRCode" }], ["/integrations/usesortable/", { "url": "/integrations/useSortable/", "hash": "useSortable" }], ["/math/creategenericprojection/", { "url": "/math/createGenericProjection/", "hash": "createGenericProjection" }], ["/math/createprojection/", { "url": "/math/createProjection/", "hash": "createProjection" }], ["/math/logicand/", { "url": "/math/logicAnd/", "hash": "logicAnd" }], ["/math/logicnot/", { "url": "/math/logicNot/", "hash": "logicNot" }], ["/math/logicor/", { "url": "/math/logicOr/", "hash": "logicOr" }], ["/math/useabs/", { "url": "/math/useAbs/", "hash": "useAbs" }], ["/math/useaverage/", { "url": "/math/useAverage/", "hash": "useAverage" }], ["/math/useceil/", { "url": "/math/useCeil/", "hash": "useCeil" }], ["/math/useclamp/", { "url": "/math/useClamp/", "hash": "useClamp" }], ["/math/usefloor/", { "url": "/math/useFloor/", "hash": "useFloor" }], ["/math/usemath/", { "url": "/math/useMath/", "hash": "useMath" }], ["/math/usemax/", { "url": "/math/useMax/", "hash": "useMax" }], ["/math/usemin/", { "url": "/math/useMin/", "hash": "useMin" }], ["/math/useprecision/", { "url": "/math/usePrecision/", "hash": "usePrecision" }], ["/math/useprojection/", { "url": "/math/useProjection/", "hash": "useProjection" }], ["/math/useround/", { "url": "/math/useRound/", "hash": "useRound" }], ["/math/usesum/", { "url": "/math/useSum/", "hash": "useSum" }], ["/math/usetrunc/", { "url": "/math/useTrunc/", "hash": "useTrunc" }], ["/router/useroutehash/", { "url": "/router/useRouteHash/", "hash": "useRouteHash" }], ["/router/userouteparams/", { "url": "/router/useRouteParams/", "hash": "useRouteParams" }], ["/router/useroutequery/", { "url": "/router/useRouteQuery/", "hash": "useRouteQuery" }], ["/rxjs/from/", { "url": "/rxjs/from/", "hash": "from" }], ["/rxjs/toobserver/", { "url": "/rxjs/toObserver/", "hash": "toObserver" }], ["/rxjs/useextractedobservable/", { "url": "/rxjs/useExtractedObservable/", "hash": "useExtractedObservable" }], ["/rxjs/useobservable/", { "url": "/rxjs/useObservable/", "hash": "useObservable" }], ["/rxjs/usesubject/", { "url": "/rxjs/useSubject/", "hash": "useSubject" }], ["/rxjs/usesubscription/", { "url": "/rxjs/useSubscription/", "hash": "useSubscription" }], ["/rxjs/watchextractedobservable/", { "url": "/rxjs/watchExtractedObservable/", "hash": "watchExtractedObservable" }]];
try {
  self["workbox:core:7.0.0"] && _();
} catch (e) {
}
const fallback = (code, ...args) => {
  let msg = code;
  if (args.length > 0) {
    msg += ` :: ${JSON.stringify(args)}`;
  }
  return msg;
};
const messageGenerator = fallback;
class WorkboxError extends Error {
  /**
   *
   * @param {string} errorCode The error code that
   * identifies this particular error.
   * @param {Object=} details Any relevant arguments
   * that will help developers identify issues should
   * be added as a key on the context object.
   */
  constructor(errorCode, details) {
    const message = messageGenerator(errorCode, details);
    super(message);
    this.name = errorCode;
    this.details = details;
  }
}
const getFriendlyURL = (url) => {
  const urlObj = new URL(String(url), location.href);
  return urlObj.href.replace(new RegExp(`^${location.origin}`), "");
};
const logger = null;
try {
  self["workbox:cacheable-response:7.0.0"] && _();
} catch (e) {
}
class CacheableResponse {
  /**
   * To construct a new CacheableResponse instance you must provide at least
   * one of the `config` properties.
   *
   * If both `statuses` and `headers` are specified, then both conditions must
   * be met for the `Response` to be considered cacheable.
   *
   * @param {Object} config
   * @param {Array<number>} [config.statuses] One or more status codes that a
   * `Response` can have and be considered cacheable.
   * @param {Object<string,string>} [config.headers] A mapping of header names
   * and expected values that a `Response` can have and be considered cacheable.
   * If multiple headers are provided, only one needs to be present.
   */
  constructor(config = {}) {
    this._statuses = config.statuses;
    this._headers = config.headers;
  }
  /**
   * Checks a response to see whether it's cacheable or not, based on this
   * object's configuration.
   *
   * @param {Response} response The response whose cacheability is being
   * checked.
   * @return {boolean} `true` if the `Response` is cacheable, and `false`
   * otherwise.
   */
  isResponseCacheable(response) {
    let cacheable = true;
    if (this._statuses) {
      cacheable = this._statuses.includes(response.status);
    }
    if (this._headers && cacheable) {
      cacheable = Object.keys(this._headers).some((headerName) => {
        return response.headers.get(headerName) === this._headers[headerName];
      });
    }
    return cacheable;
  }
}
class CacheableResponsePlugin {
  /**
   * To construct a new CacheableResponsePlugin instance you must provide at
   * least one of the `config` properties.
   *
   * If both `statuses` and `headers` are specified, then both conditions must
   * be met for the `Response` to be considered cacheable.
   *
   * @param {Object} config
   * @param {Array<number>} [config.statuses] One or more status codes that a
   * `Response` can have and be considered cacheable.
   * @param {Object<string,string>} [config.headers] A mapping of header names
   * and expected values that a `Response` can have and be considered cacheable.
   * If multiple headers are provided, only one needs to be present.
   */
  constructor(config) {
    this.cacheWillUpdate = async ({ response }) => {
      if (this._cacheableResponse.isResponseCacheable(response)) {
        return response;
      }
      return null;
    };
    this._cacheableResponse = new CacheableResponse(config);
  }
}
function dontWaitFor(promise) {
  void promise.then(() => {
  });
}
const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);
let idbProxyableTypes;
let cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const cursorRequestMap = /* @__PURE__ */ new WeakMap();
const transactionDoneMap = /* @__PURE__ */ new WeakMap();
const transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
const transformCache = /* @__PURE__ */ new WeakMap();
const reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);
function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name, version);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
function deleteDB(name, { blocked } = {}) {
  const request = indexedDB.deleteDatabase(name);
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event
    ));
  }
  return wrap(request).then(() => void 0);
}
const readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
const writeMethods = ["put", "add", "delete", "clear"];
const cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));
try {
  self["workbox:expiration:7.0.0"] && _();
} catch (e) {
}
const DB_NAME = "workbox-expiration";
const CACHE_OBJECT_STORE = "cache-entries";
const normalizeURL = (unNormalizedUrl) => {
  const url = new URL(unNormalizedUrl, location.href);
  url.hash = "";
  return url.href;
};
class CacheTimestampsModel {
  /**
   *
   * @param {string} cacheName
   *
   * @private
   */
  constructor(cacheName) {
    this._db = null;
    this._cacheName = cacheName;
  }
  /**
   * Performs an upgrade of indexedDB.
   *
   * @param {IDBPDatabase<CacheDbSchema>} db
   *
   * @private
   */
  _upgradeDb(db) {
    const objStore = db.createObjectStore(CACHE_OBJECT_STORE, { keyPath: "id" });
    objStore.createIndex("cacheName", "cacheName", { unique: false });
    objStore.createIndex("timestamp", "timestamp", { unique: false });
  }
  /**
   * Performs an upgrade of indexedDB and deletes deprecated DBs.
   *
   * @param {IDBPDatabase<CacheDbSchema>} db
   *
   * @private
   */
  _upgradeDbAndDeleteOldDbs(db) {
    this._upgradeDb(db);
    if (this._cacheName) {
      void deleteDB(this._cacheName);
    }
  }
  /**
   * @param {string} url
   * @param {number} timestamp
   *
   * @private
   */
  async setTimestamp(url, timestamp) {
    url = normalizeURL(url);
    const entry = {
      url,
      timestamp,
      cacheName: this._cacheName,
      // Creating an ID from the URL and cache name won't be necessary once
      // Edge switches to Chromium and all browsers we support work with
      // array keyPaths.
      id: this._getId(url)
    };
    const db = await this.getDb();
    const tx = db.transaction(CACHE_OBJECT_STORE, "readwrite", {
      durability: "relaxed"
    });
    await tx.store.put(entry);
    await tx.done;
  }
  /**
   * Returns the timestamp stored for a given URL.
   *
   * @param {string} url
   * @return {number | undefined}
   *
   * @private
   */
  async getTimestamp(url) {
    const db = await this.getDb();
    const entry = await db.get(CACHE_OBJECT_STORE, this._getId(url));
    return entry === null || entry === void 0 ? void 0 : entry.timestamp;
  }
  /**
   * Iterates through all the entries in the object store (from newest to
   * oldest) and removes entries once either `maxCount` is reached or the
   * entry's timestamp is less than `minTimestamp`.
   *
   * @param {number} minTimestamp
   * @param {number} maxCount
   * @return {Array<string>}
   *
   * @private
   */
  async expireEntries(minTimestamp, maxCount) {
    const db = await this.getDb();
    let cursor = await db.transaction(CACHE_OBJECT_STORE).store.index("timestamp").openCursor(null, "prev");
    const entriesToDelete = [];
    let entriesNotDeletedCount = 0;
    while (cursor) {
      const result = cursor.value;
      if (result.cacheName === this._cacheName) {
        if (minTimestamp && result.timestamp < minTimestamp || maxCount && entriesNotDeletedCount >= maxCount) {
          entriesToDelete.push(cursor.value);
        } else {
          entriesNotDeletedCount++;
        }
      }
      cursor = await cursor.continue();
    }
    const urlsDeleted = [];
    for (const entry of entriesToDelete) {
      await db.delete(CACHE_OBJECT_STORE, entry.id);
      urlsDeleted.push(entry.url);
    }
    return urlsDeleted;
  }
  /**
   * Takes a URL and returns an ID that will be unique in the object store.
   *
   * @param {string} url
   * @return {string}
   *
   * @private
   */
  _getId(url) {
    return this._cacheName + "|" + normalizeURL(url);
  }
  /**
   * Returns an open connection to the database.
   *
   * @private
   */
  async getDb() {
    if (!this._db) {
      this._db = await openDB(DB_NAME, 1, {
        upgrade: this._upgradeDbAndDeleteOldDbs.bind(this)
      });
    }
    return this._db;
  }
}
class CacheExpiration {
  /**
   * To construct a new CacheExpiration instance you must provide at least
   * one of the `config` properties.
   *
   * @param {string} cacheName Name of the cache to apply restrictions to.
   * @param {Object} config
   * @param {number} [config.maxEntries] The maximum number of entries to cache.
   * Entries used the least will be removed as the maximum is reached.
   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before
   * it's treated as stale and removed.
   * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)
   * that will be used when calling `delete()` on the cache.
   */
  constructor(cacheName, config = {}) {
    this._isRunning = false;
    this._rerunRequested = false;
    this._maxEntries = config.maxEntries;
    this._maxAgeSeconds = config.maxAgeSeconds;
    this._matchOptions = config.matchOptions;
    this._cacheName = cacheName;
    this._timestampModel = new CacheTimestampsModel(cacheName);
  }
  /**
   * Expires entries for the given cache and given criteria.
   */
  async expireEntries() {
    if (this._isRunning) {
      this._rerunRequested = true;
      return;
    }
    this._isRunning = true;
    const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1e3 : 0;
    const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);
    const cache = await self.caches.open(this._cacheName);
    for (const url of urlsExpired) {
      await cache.delete(url, this._matchOptions);
    }
    this._isRunning = false;
    if (this._rerunRequested) {
      this._rerunRequested = false;
      dontWaitFor(this.expireEntries());
    }
  }
  /**
   * Update the timestamp for the given URL. This ensures the when
   * removing entries based on maximum entries, most recently used
   * is accurate or when expiring, the timestamp is up-to-date.
   *
   * @param {string} url
   */
  async updateTimestamp(url) {
    await this._timestampModel.setTimestamp(url, Date.now());
  }
  /**
   * Can be used to check if a URL has expired or not before it's used.
   *
   * This requires a look up from IndexedDB, so can be slow.
   *
   * Note: This method will not remove the cached entry, call
   * `expireEntries()` to remove indexedDB and Cache entries.
   *
   * @param {string} url
   * @return {boolean}
   */
  async isURLExpired(url) {
    if (!this._maxAgeSeconds) {
      return false;
    } else {
      const timestamp = await this._timestampModel.getTimestamp(url);
      const expireOlderThan = Date.now() - this._maxAgeSeconds * 1e3;
      return timestamp !== void 0 ? timestamp < expireOlderThan : true;
    }
  }
  /**
   * Removes the IndexedDB object store used to keep track of cache expiration
   * metadata.
   */
  async delete() {
    this._rerunRequested = false;
    await this._timestampModel.expireEntries(Infinity);
  }
}
const _cacheNameDetails = {
  googleAnalytics: "googleAnalytics",
  precache: "precache-v2",
  prefix: "workbox",
  runtime: "runtime",
  suffix: typeof registration !== "undefined" ? registration.scope : ""
};
const _createCacheName = (cacheName) => {
  return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix].filter((value) => value && value.length > 0).join("-");
};
const eachCacheNameDetail = (fn) => {
  for (const key of Object.keys(_cacheNameDetails)) {
    fn(key);
  }
};
const cacheNames = {
  updateDetails: (details) => {
    eachCacheNameDetail((key) => {
      if (typeof details[key] === "string") {
        _cacheNameDetails[key] = details[key];
      }
    });
  },
  getGoogleAnalyticsName: (userCacheName) => {
    return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);
  },
  getPrecacheName: (userCacheName) => {
    return userCacheName || _createCacheName(_cacheNameDetails.precache);
  },
  getPrefix: () => {
    return _cacheNameDetails.prefix;
  },
  getRuntimeName: (userCacheName) => {
    return userCacheName || _createCacheName(_cacheNameDetails.runtime);
  },
  getSuffix: () => {
    return _cacheNameDetails.suffix;
  }
};
const quotaErrorCallbacks = /* @__PURE__ */ new Set();
function registerQuotaErrorCallback(callback) {
  quotaErrorCallbacks.add(callback);
}
class ExpirationPlugin {
  /**
   * @param {ExpirationPluginOptions} config
   * @param {number} [config.maxEntries] The maximum number of entries to cache.
   * Entries used the least will be removed as the maximum is reached.
   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before
   * it's treated as stale and removed.
   * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)
   * that will be used when calling `delete()` on the cache.
   * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to
   * automatic deletion if the available storage quota has been exceeded.
   */
  constructor(config = {}) {
    this.cachedResponseWillBeUsed = async ({ event, request, cacheName, cachedResponse }) => {
      if (!cachedResponse) {
        return null;
      }
      const isFresh = this._isResponseDateFresh(cachedResponse);
      const cacheExpiration = this._getCacheExpiration(cacheName);
      dontWaitFor(cacheExpiration.expireEntries());
      const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);
      if (event) {
        try {
          event.waitUntil(updateTimestampDone);
        } catch (error) {
        }
      }
      return isFresh ? cachedResponse : null;
    };
    this.cacheDidUpdate = async ({ cacheName, request }) => {
      const cacheExpiration = this._getCacheExpiration(cacheName);
      await cacheExpiration.updateTimestamp(request.url);
      await cacheExpiration.expireEntries();
    };
    this._config = config;
    this._maxAgeSeconds = config.maxAgeSeconds;
    this._cacheExpirations = /* @__PURE__ */ new Map();
    if (config.purgeOnQuotaError) {
      registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());
    }
  }
  /**
   * A simple helper method to return a CacheExpiration instance for a given
   * cache name.
   *
   * @param {string} cacheName
   * @return {CacheExpiration}
   *
   * @private
   */
  _getCacheExpiration(cacheName) {
    if (cacheName === cacheNames.getRuntimeName()) {
      throw new WorkboxError("expire-custom-caches-only");
    }
    let cacheExpiration = this._cacheExpirations.get(cacheName);
    if (!cacheExpiration) {
      cacheExpiration = new CacheExpiration(cacheName, this._config);
      this._cacheExpirations.set(cacheName, cacheExpiration);
    }
    return cacheExpiration;
  }
  /**
   * @param {Response} cachedResponse
   * @return {boolean}
   *
   * @private
   */
  _isResponseDateFresh(cachedResponse) {
    if (!this._maxAgeSeconds) {
      return true;
    }
    const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);
    if (dateHeaderTimestamp === null) {
      return true;
    }
    const now = Date.now();
    return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1e3;
  }
  /**
   * This method will extract the data header and parse it into a useful
   * value.
   *
   * @param {Response} cachedResponse
   * @return {number|null}
   *
   * @private
   */
  _getDateHeaderTimestamp(cachedResponse) {
    if (!cachedResponse.headers.has("date")) {
      return null;
    }
    const dateHeader = cachedResponse.headers.get("date");
    const parsedDate = new Date(dateHeader);
    const headerTime = parsedDate.getTime();
    if (isNaN(headerTime)) {
      return null;
    }
    return headerTime;
  }
  /**
   * This is a helper method that performs two operations:
   *
   * - Deletes *all* the underlying Cache instances associated with this plugin
   * instance, by calling caches.delete() on your behalf.
   * - Deletes the metadata from IndexedDB used to keep track of expiration
   * details for each Cache instance.
   *
   * When using cache expiration, calling this method is preferable to calling
   * `caches.delete()` directly, since this will ensure that the IndexedDB
   * metadata is also cleanly removed and open IndexedDB instances are deleted.
   *
   * Note that if you're *not* using cache expiration for a given cache, calling
   * `caches.delete()` and passing in the cache's name should be sufficient.
   * There is no Workbox-specific method needed for cleanup in that case.
   */
  async deleteCacheAndMetadata() {
    for (const [cacheName, cacheExpiration] of this._cacheExpirations) {
      await self.caches.delete(cacheName);
      await cacheExpiration.delete();
    }
    this._cacheExpirations = /* @__PURE__ */ new Map();
  }
}
function waitUntil(event, asyncFn) {
  const returnPromise = asyncFn();
  event.waitUntil(returnPromise);
  return returnPromise;
}
try {
  self["workbox:precaching:7.0.0"] && _();
} catch (e) {
}
const REVISION_SEARCH_PARAM = "__WB_REVISION__";
function createCacheKey(entry) {
  if (!entry) {
    throw new WorkboxError("add-to-cache-list-unexpected-type", { entry });
  }
  if (typeof entry === "string") {
    const urlObject = new URL(entry, location.href);
    return {
      cacheKey: urlObject.href,
      url: urlObject.href
    };
  }
  const { revision, url } = entry;
  if (!url) {
    throw new WorkboxError("add-to-cache-list-unexpected-type", { entry });
  }
  if (!revision) {
    const urlObject = new URL(url, location.href);
    return {
      cacheKey: urlObject.href,
      url: urlObject.href
    };
  }
  const cacheKeyURL = new URL(url, location.href);
  const originalURL = new URL(url, location.href);
  cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);
  return {
    cacheKey: cacheKeyURL.href,
    url: originalURL.href
  };
}
class PrecacheInstallReportPlugin {
  constructor() {
    this.updatedURLs = [];
    this.notUpdatedURLs = [];
    this.handlerWillStart = async ({ request, state }) => {
      if (state) {
        state.originalRequest = request;
      }
    };
    this.cachedResponseWillBeUsed = async ({ event, state, cachedResponse }) => {
      if (event.type === "install") {
        if (state && state.originalRequest && state.originalRequest instanceof Request) {
          const url = state.originalRequest.url;
          if (cachedResponse) {
            this.notUpdatedURLs.push(url);
          } else {
            this.updatedURLs.push(url);
          }
        }
      }
      return cachedResponse;
    };
  }
}
class PrecacheCacheKeyPlugin {
  constructor({ precacheController: precacheController2 }) {
    this.cacheKeyWillBeUsed = async ({ request, params }) => {
      const cacheKey = (params === null || params === void 0 ? void 0 : params.cacheKey) || this._precacheController.getCacheKeyForURL(request.url);
      return cacheKey ? new Request(cacheKey, { headers: request.headers }) : request;
    };
    this._precacheController = precacheController2;
  }
}
let supportStatus;
function canConstructResponseFromBodyStream() {
  if (supportStatus === void 0) {
    const testResponse = new Response("");
    if ("body" in testResponse) {
      try {
        new Response(testResponse.body);
        supportStatus = true;
      } catch (error) {
        supportStatus = false;
      }
    }
    supportStatus = false;
  }
  return supportStatus;
}
async function copyResponse(response, modifier) {
  let origin = null;
  if (response.url) {
    const responseURL = new URL(response.url);
    origin = responseURL.origin;
  }
  if (origin !== self.location.origin) {
    throw new WorkboxError("cross-origin-copy-response", { origin });
  }
  const clonedResponse = response.clone();
  const responseInit = {
    headers: new Headers(clonedResponse.headers),
    status: clonedResponse.status,
    statusText: clonedResponse.statusText
  };
  const modifiedResponseInit = responseInit;
  const body = canConstructResponseFromBodyStream() ? clonedResponse.body : await clonedResponse.blob();
  return new Response(body, modifiedResponseInit);
}
function stripParams(fullURL, ignoreParams) {
  const strippedURL = new URL(fullURL);
  for (const param of ignoreParams) {
    strippedURL.searchParams.delete(param);
  }
  return strippedURL.href;
}
async function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {
  const strippedRequestURL = stripParams(request.url, ignoreParams);
  if (request.url === strippedRequestURL) {
    return cache.match(request, matchOptions);
  }
  const keysOptions = Object.assign(Object.assign({}, matchOptions), { ignoreSearch: true });
  const cacheKeys = await cache.keys(request, keysOptions);
  for (const cacheKey of cacheKeys) {
    const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);
    if (strippedRequestURL === strippedCacheKeyURL) {
      return cache.match(cacheKey, matchOptions);
    }
  }
  return;
}
class Deferred {
  /**
   * Creates a promise and exposes its resolve and reject functions as methods.
   */
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
}
async function executeQuotaErrorCallbacks() {
  for (const callback of quotaErrorCallbacks) {
    await callback();
  }
}
function timeout(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
try {
  self["workbox:strategies:7.0.0"] && _();
} catch (e) {
}
function toRequest(input) {
  return typeof input === "string" ? new Request(input) : input;
}
class StrategyHandler {
  /**
   * Creates a new instance associated with the passed strategy and event
   * that's handling the request.
   *
   * The constructor also initializes the state that will be passed to each of
   * the plugins handling this request.
   *
   * @param {workbox-strategies.Strategy} strategy
   * @param {Object} options
   * @param {Request|string} options.request A request to run this strategy for.
   * @param {ExtendableEvent} options.event The event associated with the
   *     request.
   * @param {URL} [options.url]
   * @param {*} [options.params] The return value from the
   *     {@link workbox-routing~matchCallback} (if applicable).
   */
  constructor(strategy, options) {
    this._cacheKeys = {};
    Object.assign(this, options);
    this.event = options.event;
    this._strategy = strategy;
    this._handlerDeferred = new Deferred();
    this._extendLifetimePromises = [];
    this._plugins = [...strategy.plugins];
    this._pluginStateMap = /* @__PURE__ */ new Map();
    for (const plugin of this._plugins) {
      this._pluginStateMap.set(plugin, {});
    }
    this.event.waitUntil(this._handlerDeferred.promise);
  }
  /**
   * Fetches a given request (and invokes any applicable plugin callback
   * methods) using the `fetchOptions` (for non-navigation requests) and
   * `plugins` defined on the `Strategy` object.
   *
   * The following plugin lifecycle methods are invoked when using this method:
   * - `requestWillFetch()`
   * - `fetchDidSucceed()`
   * - `fetchDidFail()`
   *
   * @param {Request|string} input The URL or request to fetch.
   * @return {Promise<Response>}
   */
  async fetch(input) {
    const { event } = this;
    let request = toRequest(input);
    if (request.mode === "navigate" && event instanceof FetchEvent && event.preloadResponse) {
      const possiblePreloadResponse = await event.preloadResponse;
      if (possiblePreloadResponse) {
        return possiblePreloadResponse;
      }
    }
    const originalRequest = this.hasCallback("fetchDidFail") ? request.clone() : null;
    try {
      for (const cb of this.iterateCallbacks("requestWillFetch")) {
        request = await cb({ request: request.clone(), event });
      }
    } catch (err) {
      if (err instanceof Error) {
        throw new WorkboxError("plugin-error-request-will-fetch", {
          thrownErrorMessage: err.message
        });
      }
    }
    const pluginFilteredRequest = request.clone();
    try {
      let fetchResponse;
      fetchResponse = await fetch(request, request.mode === "navigate" ? void 0 : this._strategy.fetchOptions);
      if (false) ;
      for (const callback of this.iterateCallbacks("fetchDidSucceed")) {
        fetchResponse = await callback({
          event,
          request: pluginFilteredRequest,
          response: fetchResponse
        });
      }
      return fetchResponse;
    } catch (error) {
      if (originalRequest) {
        await this.runCallbacks("fetchDidFail", {
          error,
          event,
          originalRequest: originalRequest.clone(),
          request: pluginFilteredRequest.clone()
        });
      }
      throw error;
    }
  }
  /**
   * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on
   * the response generated by `this.fetch()`.
   *
   * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,
   * so you do not have to manually call `waitUntil()` on the event.
   *
   * @param {Request|string} input The request or URL to fetch and cache.
   * @return {Promise<Response>}
   */
  async fetchAndCachePut(input) {
    const response = await this.fetch(input);
    const responseClone = response.clone();
    void this.waitUntil(this.cachePut(input, responseClone));
    return response;
  }
  /**
   * Matches a request from the cache (and invokes any applicable plugin
   * callback methods) using the `cacheName`, `matchOptions`, and `plugins`
   * defined on the strategy object.
   *
   * The following plugin lifecycle methods are invoked when using this method:
   * - cacheKeyWillByUsed()
   * - cachedResponseWillByUsed()
   *
   * @param {Request|string} key The Request or URL to use as the cache key.
   * @return {Promise<Response|undefined>} A matching response, if found.
   */
  async cacheMatch(key) {
    const request = toRequest(key);
    let cachedResponse;
    const { cacheName, matchOptions } = this._strategy;
    const effectiveRequest = await this.getCacheKey(request, "read");
    const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), { cacheName });
    cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);
    for (const callback of this.iterateCallbacks("cachedResponseWillBeUsed")) {
      cachedResponse = await callback({
        cacheName,
        matchOptions,
        cachedResponse,
        request: effectiveRequest,
        event: this.event
      }) || void 0;
    }
    return cachedResponse;
  }
  /**
   * Puts a request/response pair in the cache (and invokes any applicable
   * plugin callback methods) using the `cacheName` and `plugins` defined on
   * the strategy object.
   *
   * The following plugin lifecycle methods are invoked when using this method:
   * - cacheKeyWillByUsed()
   * - cacheWillUpdate()
   * - cacheDidUpdate()
   *
   * @param {Request|string} key The request or URL to use as the cache key.
   * @param {Response} response The response to cache.
   * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response
   * not be cached, and `true` otherwise.
   */
  async cachePut(key, response) {
    const request = toRequest(key);
    await timeout(0);
    const effectiveRequest = await this.getCacheKey(request, "write");
    if (!response) {
      throw new WorkboxError("cache-put-with-no-response", {
        url: getFriendlyURL(effectiveRequest.url)
      });
    }
    const responseToCache = await this._ensureResponseSafeToCache(response);
    if (!responseToCache) {
      return false;
    }
    const { cacheName, matchOptions } = this._strategy;
    const cache = await self.caches.open(cacheName);
    const hasCacheUpdateCallback = this.hasCallback("cacheDidUpdate");
    const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(
      // TODO(philipwalton): the `__WB_REVISION__` param is a precaching
      // feature. Consider into ways to only add this behavior if using
      // precaching.
      cache,
      effectiveRequest.clone(),
      ["__WB_REVISION__"],
      matchOptions
    ) : null;
    try {
      await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);
    } catch (error) {
      if (error instanceof Error) {
        if (error.name === "QuotaExceededError") {
          await executeQuotaErrorCallbacks();
        }
        throw error;
      }
    }
    for (const callback of this.iterateCallbacks("cacheDidUpdate")) {
      await callback({
        cacheName,
        oldResponse,
        newResponse: responseToCache.clone(),
        request: effectiveRequest,
        event: this.event
      });
    }
    return true;
  }
  /**
   * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and
   * executes any of those callbacks found in sequence. The final `Request`
   * object returned by the last plugin is treated as the cache key for cache
   * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have
   * been registered, the passed request is returned unmodified
   *
   * @param {Request} request
   * @param {string} mode
   * @return {Promise<Request>}
   */
  async getCacheKey(request, mode) {
    const key = `${request.url} | ${mode}`;
    if (!this._cacheKeys[key]) {
      let effectiveRequest = request;
      for (const callback of this.iterateCallbacks("cacheKeyWillBeUsed")) {
        effectiveRequest = toRequest(await callback({
          mode,
          request: effectiveRequest,
          event: this.event,
          // params has a type any can't change right now.
          params: this.params
          // eslint-disable-line
        }));
      }
      this._cacheKeys[key] = effectiveRequest;
    }
    return this._cacheKeys[key];
  }
  /**
   * Returns true if the strategy has at least one plugin with the given
   * callback.
   *
   * @param {string} name The name of the callback to check for.
   * @return {boolean}
   */
  hasCallback(name) {
    for (const plugin of this._strategy.plugins) {
      if (name in plugin) {
        return true;
      }
    }
    return false;
  }
  /**
   * Runs all plugin callbacks matching the given name, in order, passing the
   * given param object (merged ith the current plugin state) as the only
   * argument.
   *
   * Note: since this method runs all plugins, it's not suitable for cases
   * where the return value of a callback needs to be applied prior to calling
   * the next callback. See
   * {@link workbox-strategies.StrategyHandler#iterateCallbacks}
   * below for how to handle that case.
   *
   * @param {string} name The name of the callback to run within each plugin.
   * @param {Object} param The object to pass as the first (and only) param
   *     when executing each callback. This object will be merged with the
   *     current plugin state prior to callback execution.
   */
  async runCallbacks(name, param) {
    for (const callback of this.iterateCallbacks(name)) {
      await callback(param);
    }
  }
  /**
   * Accepts a callback and returns an iterable of matching plugin callbacks,
   * where each callback is wrapped with the current handler state (i.e. when
   * you call each callback, whatever object parameter you pass it will
   * be merged with the plugin's current state).
   *
   * @param {string} name The name fo the callback to run
   * @return {Array<Function>}
   */
  *iterateCallbacks(name) {
    for (const plugin of this._strategy.plugins) {
      if (typeof plugin[name] === "function") {
        const state = this._pluginStateMap.get(plugin);
        const statefulCallback = (param) => {
          const statefulParam = Object.assign(Object.assign({}, param), { state });
          return plugin[name](statefulParam);
        };
        yield statefulCallback;
      }
    }
  }
  /**
   * Adds a promise to the
   * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}
   * of the event event associated with the request being handled (usually a
   * `FetchEvent`).
   *
   * Note: you can await
   * {@link workbox-strategies.StrategyHandler~doneWaiting}
   * to know when all added promises have settled.
   *
   * @param {Promise} promise A promise to add to the extend lifetime promises
   *     of the event that triggered the request.
   */
  waitUntil(promise) {
    this._extendLifetimePromises.push(promise);
    return promise;
  }
  /**
   * Returns a promise that resolves once all promises passed to
   * {@link workbox-strategies.StrategyHandler~waitUntil}
   * have settled.
   *
   * Note: any work done after `doneWaiting()` settles should be manually
   * passed to an event's `waitUntil()` method (not this handler's
   * `waitUntil()` method), otherwise the service worker thread my be killed
   * prior to your work completing.
   */
  async doneWaiting() {
    let promise;
    while (promise = this._extendLifetimePromises.shift()) {
      await promise;
    }
  }
  /**
   * Stops running the strategy and immediately resolves any pending
   * `waitUntil()` promises.
   */
  destroy() {
    this._handlerDeferred.resolve(null);
  }
  /**
   * This method will call cacheWillUpdate on the available plugins (or use
   * status === 200) to determine if the Response is safe and valid to cache.
   *
   * @param {Request} options.request
   * @param {Response} options.response
   * @return {Promise<Response|undefined>}
   *
   * @private
   */
  async _ensureResponseSafeToCache(response) {
    let responseToCache = response;
    let pluginsUsed = false;
    for (const callback of this.iterateCallbacks("cacheWillUpdate")) {
      responseToCache = await callback({
        request: this.request,
        response: responseToCache,
        event: this.event
      }) || void 0;
      pluginsUsed = true;
      if (!responseToCache) {
        break;
      }
    }
    if (!pluginsUsed) {
      if (responseToCache && responseToCache.status !== 200) {
        responseToCache = void 0;
      }
    }
    return responseToCache;
  }
}
class Strategy {
  /**
   * Creates a new instance of the strategy and sets all documented option
   * properties as public instance properties.
   *
   * Note: if a custom strategy class extends the base Strategy class and does
   * not need more than these properties, it does not need to define its own
   * constructor.
   *
   * @param {Object} [options]
   * @param {string} [options.cacheName] Cache name to store and retrieve
   * requests. Defaults to the cache names provided by
   * {@link workbox-core.cacheNames}.
   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
   * to use in conjunction with this caching strategy.
   * @param {Object} [options.fetchOptions] Values passed along to the
   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
   * `fetch()` requests made by this strategy.
   * @param {Object} [options.matchOptions] The
   * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
   * for any `cache.match()` or `cache.put()` calls made by this strategy.
   */
  constructor(options = {}) {
    this.cacheName = cacheNames.getRuntimeName(options.cacheName);
    this.plugins = options.plugins || [];
    this.fetchOptions = options.fetchOptions;
    this.matchOptions = options.matchOptions;
  }
  /**
   * Perform a request strategy and returns a `Promise` that will resolve with
   * a `Response`, invoking all relevant plugin callbacks.
   *
   * When a strategy instance is registered with a Workbox
   * {@link workbox-routing.Route}, this method is automatically
   * called when the route matches.
   *
   * Alternatively, this method can be used in a standalone `FetchEvent`
   * listener by passing it to `event.respondWith()`.
   *
   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
   *     properties listed below.
   * @param {Request|string} options.request A request to run this strategy for.
   * @param {ExtendableEvent} options.event The event associated with the
   *     request.
   * @param {URL} [options.url]
   * @param {*} [options.params]
   */
  handle(options) {
    const [responseDone] = this.handleAll(options);
    return responseDone;
  }
  /**
   * Similar to {@link workbox-strategies.Strategy~handle}, but
   * instead of just returning a `Promise` that resolves to a `Response` it
   * it will return an tuple of `[response, done]` promises, where the former
   * (`response`) is equivalent to what `handle()` returns, and the latter is a
   * Promise that will resolve once any promises that were added to
   * `event.waitUntil()` as part of performing the strategy have completed.
   *
   * You can await the `done` promise to ensure any extra work performed by
   * the strategy (usually caching responses) completes successfully.
   *
   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
   *     properties listed below.
   * @param {Request|string} options.request A request to run this strategy for.
   * @param {ExtendableEvent} options.event The event associated with the
   *     request.
   * @param {URL} [options.url]
   * @param {*} [options.params]
   * @return {Array<Promise>} A tuple of [response, done]
   *     promises that can be used to determine when the response resolves as
   *     well as when the handler has completed all its work.
   */
  handleAll(options) {
    if (options instanceof FetchEvent) {
      options = {
        event: options,
        request: options.request
      };
    }
    const event = options.event;
    const request = typeof options.request === "string" ? new Request(options.request) : options.request;
    const params = "params" in options ? options.params : void 0;
    const handler = new StrategyHandler(this, { event, request, params });
    const responseDone = this._getResponse(handler, request, event);
    const handlerDone = this._awaitComplete(responseDone, handler, request, event);
    return [responseDone, handlerDone];
  }
  async _getResponse(handler, request, event) {
    await handler.runCallbacks("handlerWillStart", { event, request });
    let response = void 0;
    try {
      response = await this._handle(request, handler);
      if (!response || response.type === "error") {
        throw new WorkboxError("no-response", { url: request.url });
      }
    } catch (error) {
      if (error instanceof Error) {
        for (const callback of handler.iterateCallbacks("handlerDidError")) {
          response = await callback({ error, event, request });
          if (response) {
            break;
          }
        }
      }
      if (!response) {
        throw error;
      }
    }
    for (const callback of handler.iterateCallbacks("handlerWillRespond")) {
      response = await callback({ event, request, response });
    }
    return response;
  }
  async _awaitComplete(responseDone, handler, request, event) {
    let response;
    let error;
    try {
      response = await responseDone;
    } catch (error2) {
    }
    try {
      await handler.runCallbacks("handlerDidRespond", {
        event,
        request,
        response
      });
      await handler.doneWaiting();
    } catch (waitUntilError) {
      if (waitUntilError instanceof Error) {
        error = waitUntilError;
      }
    }
    await handler.runCallbacks("handlerDidComplete", {
      event,
      request,
      response,
      error
    });
    handler.destroy();
    if (error) {
      throw error;
    }
  }
}
class PrecacheStrategy extends Strategy {
  /**
   *
   * @param {Object} [options]
   * @param {string} [options.cacheName] Cache name to store and retrieve
   * requests. Defaults to the cache names provided by
   * {@link workbox-core.cacheNames}.
   * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}
   * to use in conjunction with this caching strategy.
   * @param {Object} [options.fetchOptions] Values passed along to the
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}
   * of all fetch() requests made by this strategy.
   * @param {Object} [options.matchOptions] The
   * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}
   * for any `cache.match()` or `cache.put()` calls made by this strategy.
   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
   * get the response from the network if there's a precache miss.
   */
  constructor(options = {}) {
    options.cacheName = cacheNames.getPrecacheName(options.cacheName);
    super(options);
    this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true;
    this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);
  }
  /**
   * @private
   * @param {Request|string} request A request to run this strategy for.
   * @param {workbox-strategies.StrategyHandler} handler The event that
   *     triggered the request.
   * @return {Promise<Response>}
   */
  async _handle(request, handler) {
    const response = await handler.cacheMatch(request);
    if (response) {
      return response;
    }
    if (handler.event && handler.event.type === "install") {
      return await this._handleInstall(request, handler);
    }
    return await this._handleFetch(request, handler);
  }
  async _handleFetch(request, handler) {
    let response;
    const params = handler.params || {};
    if (this._fallbackToNetwork) {
      const integrityInManifest = params.integrity;
      const integrityInRequest = request.integrity;
      const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;
      response = await handler.fetch(new Request(request, {
        integrity: request.mode !== "no-cors" ? integrityInRequest || integrityInManifest : void 0
      }));
      if (integrityInManifest && noIntegrityConflict && request.mode !== "no-cors") {
        this._useDefaultCacheabilityPluginIfNeeded();
        await handler.cachePut(request, response.clone());
      }
    } else {
      throw new WorkboxError("missing-precache-entry", {
        cacheName: this.cacheName,
        url: request.url
      });
    }
    return response;
  }
  async _handleInstall(request, handler) {
    this._useDefaultCacheabilityPluginIfNeeded();
    const response = await handler.fetch(request);
    const wasCached = await handler.cachePut(request, response.clone());
    if (!wasCached) {
      throw new WorkboxError("bad-precaching-response", {
        url: request.url,
        status: response.status
      });
    }
    return response;
  }
  /**
   * This method is complex, as there a number of things to account for:
   *
   * The `plugins` array can be set at construction, and/or it might be added to
   * to at any time before the strategy is used.
   *
   * At the time the strategy is used (i.e. during an `install` event), there
   * needs to be at least one plugin that implements `cacheWillUpdate` in the
   * array, other than `copyRedirectedCacheableResponsesPlugin`.
   *
   * - If this method is called and there are no suitable `cacheWillUpdate`
   * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.
   *
   * - If this method is called and there is exactly one `cacheWillUpdate`, then
   * we don't have to do anything (this might be a previously added
   * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).
   *
   * - If this method is called and there is more than one `cacheWillUpdate`,
   * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,
   * we need to remove it. (This situation is unlikely, but it could happen if
   * the strategy is used multiple times, the first without a `cacheWillUpdate`,
   * and then later on after manually adding a custom `cacheWillUpdate`.)
   *
   * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.
   *
   * @private
   */
  _useDefaultCacheabilityPluginIfNeeded() {
    let defaultPluginIndex = null;
    let cacheWillUpdatePluginCount = 0;
    for (const [index, plugin] of this.plugins.entries()) {
      if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {
        continue;
      }
      if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {
        defaultPluginIndex = index;
      }
      if (plugin.cacheWillUpdate) {
        cacheWillUpdatePluginCount++;
      }
    }
    if (cacheWillUpdatePluginCount === 0) {
      this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);
    } else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {
      this.plugins.splice(defaultPluginIndex, 1);
    }
  }
}
PrecacheStrategy.defaultPrecacheCacheabilityPlugin = {
  async cacheWillUpdate({ response }) {
    if (!response || response.status >= 400) {
      return null;
    }
    return response;
  }
};
PrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {
  async cacheWillUpdate({ response }) {
    return response.redirected ? await copyResponse(response) : response;
  }
};
class PrecacheController {
  /**
   * Create a new PrecacheController.
   *
   * @param {Object} [options]
   * @param {string} [options.cacheName] The cache to use for precaching.
   * @param {string} [options.plugins] Plugins to use when precaching as well
   * as responding to fetch events for precached assets.
   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
   * get the response from the network if there's a precache miss.
   */
  constructor({ cacheName, plugins = [], fallbackToNetwork = true } = {}) {
    this._urlsToCacheKeys = /* @__PURE__ */ new Map();
    this._urlsToCacheModes = /* @__PURE__ */ new Map();
    this._cacheKeysToIntegrities = /* @__PURE__ */ new Map();
    this._strategy = new PrecacheStrategy({
      cacheName: cacheNames.getPrecacheName(cacheName),
      plugins: [
        ...plugins,
        new PrecacheCacheKeyPlugin({ precacheController: this })
      ],
      fallbackToNetwork
    });
    this.install = this.install.bind(this);
    this.activate = this.activate.bind(this);
  }
  /**
   * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and
   * used to cache assets and respond to fetch events.
   */
  get strategy() {
    return this._strategy;
  }
  /**
   * Adds items to the precache list, removing any duplicates and
   * stores the files in the
   * {@link workbox-core.cacheNames|"precache cache"} when the service
   * worker installs.
   *
   * This method can be called multiple times.
   *
   * @param {Array<Object|string>} [entries=[]] Array of entries to precache.
   */
  precache(entries2) {
    this.addToCacheList(entries2);
    if (!this._installAndActiveListenersAdded) {
      self.addEventListener("install", this.install);
      self.addEventListener("activate", this.activate);
      this._installAndActiveListenersAdded = true;
    }
  }
  /**
   * This method will add items to the precache list, removing duplicates
   * and ensuring the information is valid.
   *
   * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries
   *     Array of entries to precache.
   */
  addToCacheList(entries2) {
    const urlsToWarnAbout = [];
    for (const entry of entries2) {
      if (typeof entry === "string") {
        urlsToWarnAbout.push(entry);
      } else if (entry && entry.revision === void 0) {
        urlsToWarnAbout.push(entry.url);
      }
      const { cacheKey, url } = createCacheKey(entry);
      const cacheMode = typeof entry !== "string" && entry.revision ? "reload" : "default";
      if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {
        throw new WorkboxError("add-to-cache-list-conflicting-entries", {
          firstEntry: this._urlsToCacheKeys.get(url),
          secondEntry: cacheKey
        });
      }
      if (typeof entry !== "string" && entry.integrity) {
        if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {
          throw new WorkboxError("add-to-cache-list-conflicting-integrities", {
            url
          });
        }
        this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);
      }
      this._urlsToCacheKeys.set(url, cacheKey);
      this._urlsToCacheModes.set(url, cacheMode);
      if (urlsToWarnAbout.length > 0) {
        const warningMessage = `Workbox is precaching URLs without revision info: ${urlsToWarnAbout.join(", ")}
This is generally NOT safe. Learn more at https://bit.ly/wb-precache`;
        {
          console.warn(warningMessage);
        }
      }
    }
  }
  /**
   * Precaches new and updated assets. Call this method from the service worker
   * install event.
   *
   * Note: this method calls `event.waitUntil()` for you, so you do not need
   * to call it yourself in your event handlers.
   *
   * @param {ExtendableEvent} event
   * @return {Promise<workbox-precaching.InstallResult>}
   */
  install(event) {
    return waitUntil(event, async () => {
      const installReportPlugin = new PrecacheInstallReportPlugin();
      this.strategy.plugins.push(installReportPlugin);
      for (const [url, cacheKey] of this._urlsToCacheKeys) {
        const integrity = this._cacheKeysToIntegrities.get(cacheKey);
        const cacheMode = this._urlsToCacheModes.get(url);
        const request = new Request(url, {
          integrity,
          cache: cacheMode,
          credentials: "same-origin"
        });
        await Promise.all(this.strategy.handleAll({
          params: { cacheKey },
          request,
          event
        }));
      }
      const { updatedURLs, notUpdatedURLs } = installReportPlugin;
      return { updatedURLs, notUpdatedURLs };
    });
  }
  /**
   * Deletes assets that are no longer present in the current precache manifest.
   * Call this method from the service worker activate event.
   *
   * Note: this method calls `event.waitUntil()` for you, so you do not need
   * to call it yourself in your event handlers.
   *
   * @param {ExtendableEvent} event
   * @return {Promise<workbox-precaching.CleanupResult>}
   */
  activate(event) {
    return waitUntil(event, async () => {
      const cache = await self.caches.open(this.strategy.cacheName);
      const currentlyCachedRequests = await cache.keys();
      const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());
      const deletedURLs = [];
      for (const request of currentlyCachedRequests) {
        if (!expectedCacheKeys.has(request.url)) {
          await cache.delete(request);
          deletedURLs.push(request.url);
        }
      }
      return { deletedURLs };
    });
  }
  /**
   * Returns a mapping of a precached URL to the corresponding cache key, taking
   * into account the revision information for the URL.
   *
   * @return {Map<string, string>} A URL to cache key mapping.
   */
  getURLsToCacheKeys() {
    return this._urlsToCacheKeys;
  }
  /**
   * Returns a list of all the URLs that have been precached by the current
   * service worker.
   *
   * @return {Array<string>} The precached URLs.
   */
  getCachedURLs() {
    return [...this._urlsToCacheKeys.keys()];
  }
  /**
   * Returns the cache key used for storing a given URL. If that URL is
   * unversioned, like `/index.html', then the cache key will be the original
   * URL with a search parameter appended to it.
   *
   * @param {string} url A URL whose cache key you want to look up.
   * @return {string} The versioned URL that corresponds to a cache key
   * for the original URL, or undefined if that URL isn't precached.
   */
  getCacheKeyForURL(url) {
    const urlObject = new URL(url, location.href);
    return this._urlsToCacheKeys.get(urlObject.href);
  }
  /**
   * @param {string} url A cache key whose SRI you want to look up.
   * @return {string} The subresource integrity associated with the cache key,
   * or undefined if it's not set.
   */
  getIntegrityForCacheKey(cacheKey) {
    return this._cacheKeysToIntegrities.get(cacheKey);
  }
  /**
   * This acts as a drop-in replacement for
   * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)
   * with the following differences:
   *
   * - It knows what the name of the precache is, and only checks in that cache.
   * - It allows you to pass in an "original" URL without versioning parameters,
   * and it will automatically look up the correct cache key for the currently
   * active revision of that URL.
   *
   * E.g., `matchPrecache('index.html')` will find the correct precached
   * response for the currently active service worker, even if the actual cache
   * key is `'/index.html?__WB_REVISION__=1234abcd'`.
   *
   * @param {string|Request} request The key (without revisioning parameters)
   * to look up in the precache.
   * @return {Promise<Response|undefined>}
   */
  async matchPrecache(request) {
    const url = request instanceof Request ? request.url : request;
    const cacheKey = this.getCacheKeyForURL(url);
    if (cacheKey) {
      const cache = await self.caches.open(this.strategy.cacheName);
      return cache.match(cacheKey);
    }
    return void 0;
  }
  /**
   * Returns a function that looks up `url` in the precache (taking into
   * account revision information), and returns the corresponding `Response`.
   *
   * @param {string} url The precached URL which will be used to lookup the
   * `Response`.
   * @return {workbox-routing~handlerCallback}
   */
  createHandlerBoundToURL(url) {
    const cacheKey = this.getCacheKeyForURL(url);
    if (!cacheKey) {
      throw new WorkboxError("non-precached-url", { url });
    }
    return (options) => {
      options.request = new Request(url);
      options.params = Object.assign({ cacheKey }, options.params);
      return this.strategy.handle(options);
    };
  }
}
let precacheController;
const getOrCreatePrecacheController = () => {
  if (!precacheController) {
    precacheController = new PrecacheController();
  }
  return precacheController;
};
try {
  self["workbox:routing:7.0.0"] && _();
} catch (e) {
}
const defaultMethod = "GET";
const normalizeHandler = (handler) => {
  if (handler && typeof handler === "object") {
    return handler;
  } else {
    return { handle: handler };
  }
};
class Route {
  /**
   * Constructor for Route class.
   *
   * @param {workbox-routing~matchCallback} match
   * A callback function that determines whether the route matches a given
   * `fetch` event by returning a non-falsy value.
   * @param {workbox-routing~handlerCallback} handler A callback
   * function that returns a Promise resolving to a Response.
   * @param {string} [method='GET'] The HTTP method to match the Route
   * against.
   */
  constructor(match, handler, method = defaultMethod) {
    this.handler = normalizeHandler(handler);
    this.match = match;
    this.method = method;
  }
  /**
   *
   * @param {workbox-routing-handlerCallback} handler A callback
   * function that returns a Promise resolving to a Response
   */
  setCatchHandler(handler) {
    this.catchHandler = normalizeHandler(handler);
  }
}
class RegExpRoute extends Route {
  /**
   * If the regular expression contains
   * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},
   * the captured values will be passed to the
   * {@link workbox-routing~handlerCallback} `params`
   * argument.
   *
   * @param {RegExp} regExp The regular expression to match against URLs.
   * @param {workbox-routing~handlerCallback} handler A callback
   * function that returns a Promise resulting in a Response.
   * @param {string} [method='GET'] The HTTP method to match the Route
   * against.
   */
  constructor(regExp, handler, method) {
    const match = ({ url }) => {
      const result = regExp.exec(url.href);
      if (!result) {
        return;
      }
      if (url.origin !== location.origin && result.index !== 0) {
        return;
      }
      return result.slice(1);
    };
    super(match, handler, method);
  }
}
class Router {
  /**
   * Initializes a new Router.
   */
  constructor() {
    this._routes = /* @__PURE__ */ new Map();
    this._defaultHandlerMap = /* @__PURE__ */ new Map();
  }
  /**
   * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP
   * method name ('GET', etc.) to an array of all the corresponding `Route`
   * instances that are registered.
   */
  get routes() {
    return this._routes;
  }
  /**
   * Adds a fetch event listener to respond to events when a route matches
   * the event's request.
   */
  addFetchListener() {
    self.addEventListener("fetch", (event) => {
      const { request } = event;
      const responsePromise = this.handleRequest({ request, event });
      if (responsePromise) {
        event.respondWith(responsePromise);
      }
    });
  }
  /**
   * Adds a message event listener for URLs to cache from the window.
   * This is useful to cache resources loaded on the page prior to when the
   * service worker started controlling it.
   *
   * The format of the message data sent from the window should be as follows.
   * Where the `urlsToCache` array may consist of URL strings or an array of
   * URL string + `requestInit` object (the same as you'd pass to `fetch()`).
   *
   * ```
   * {
   *   type: 'CACHE_URLS',
   *   payload: {
   *     urlsToCache: [
   *       './script1.js',
   *       './script2.js',
   *       ['./script3.js', {mode: 'no-cors'}],
   *     ],
   *   },
   * }
   * ```
   */
  addCacheListener() {
    self.addEventListener("message", (event) => {
      if (event.data && event.data.type === "CACHE_URLS") {
        const { payload } = event.data;
        const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {
          if (typeof entry === "string") {
            entry = [entry];
          }
          const request = new Request(...entry);
          return this.handleRequest({ request, event });
        }));
        event.waitUntil(requestPromises);
        if (event.ports && event.ports[0]) {
          void requestPromises.then(() => event.ports[0].postMessage(true));
        }
      }
    });
  }
  /**
   * Apply the routing rules to a FetchEvent object to get a Response from an
   * appropriate Route's handler.
   *
   * @param {Object} options
   * @param {Request} options.request The request to handle.
   * @param {ExtendableEvent} options.event The event that triggered the
   *     request.
   * @return {Promise<Response>|undefined} A promise is returned if a
   *     registered route can handle the request. If there is no matching
   *     route and there's no `defaultHandler`, `undefined` is returned.
   */
  handleRequest({ request, event }) {
    const url = new URL(request.url, location.href);
    if (!url.protocol.startsWith("http")) {
      return;
    }
    const sameOrigin = url.origin === location.origin;
    const { params, route } = this.findMatchingRoute({
      event,
      request,
      sameOrigin,
      url
    });
    let handler = route && route.handler;
    const method = request.method;
    if (!handler && this._defaultHandlerMap.has(method)) {
      handler = this._defaultHandlerMap.get(method);
    }
    if (!handler) {
      return;
    }
    let responsePromise;
    try {
      responsePromise = handler.handle({ url, request, event, params });
    } catch (err) {
      responsePromise = Promise.reject(err);
    }
    const catchHandler = route && route.catchHandler;
    if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {
      responsePromise = responsePromise.catch(async (err) => {
        if (catchHandler) {
          try {
            return await catchHandler.handle({ url, request, event, params });
          } catch (catchErr) {
            if (catchErr instanceof Error) {
              err = catchErr;
            }
          }
        }
        if (this._catchHandler) {
          return this._catchHandler.handle({ url, request, event });
        }
        throw err;
      });
    }
    return responsePromise;
  }
  /**
   * Checks a request and URL (and optionally an event) against the list of
   * registered routes, and if there's a match, returns the corresponding
   * route along with any params generated by the match.
   *
   * @param {Object} options
   * @param {URL} options.url
   * @param {boolean} options.sameOrigin The result of comparing `url.origin`
   *     against the current origin.
   * @param {Request} options.request The request to match.
   * @param {Event} options.event The corresponding event.
   * @return {Object} An object with `route` and `params` properties.
   *     They are populated if a matching route was found or `undefined`
   *     otherwise.
   */
  findMatchingRoute({ url, sameOrigin, request, event }) {
    const routes = this._routes.get(request.method) || [];
    for (const route of routes) {
      let params;
      const matchResult = route.match({ url, sameOrigin, request, event });
      if (matchResult) {
        params = matchResult;
        if (Array.isArray(params) && params.length === 0) {
          params = void 0;
        } else if (matchResult.constructor === Object && // eslint-disable-line
        Object.keys(matchResult).length === 0) {
          params = void 0;
        } else if (typeof matchResult === "boolean") {
          params = void 0;
        }
        return { route, params };
      }
    }
    return {};
  }
  /**
   * Define a default `handler` that's called when no routes explicitly
   * match the incoming request.
   *
   * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.
   *
   * Without a default handler, unmatched requests will go against the
   * network as if there were no service worker present.
   *
   * @param {workbox-routing~handlerCallback} handler A callback
   * function that returns a Promise resulting in a Response.
   * @param {string} [method='GET'] The HTTP method to associate with this
   * default handler. Each method has its own default.
   */
  setDefaultHandler(handler, method = defaultMethod) {
    this._defaultHandlerMap.set(method, normalizeHandler(handler));
  }
  /**
   * If a Route throws an error while handling a request, this `handler`
   * will be called and given a chance to provide a response.
   *
   * @param {workbox-routing~handlerCallback} handler A callback
   * function that returns a Promise resulting in a Response.
   */
  setCatchHandler(handler) {
    this._catchHandler = normalizeHandler(handler);
  }
  /**
   * Registers a route with the router.
   *
   * @param {workbox-routing.Route} route The route to register.
   */
  registerRoute(route) {
    if (!this._routes.has(route.method)) {
      this._routes.set(route.method, []);
    }
    this._routes.get(route.method).push(route);
  }
  /**
   * Unregisters a route with the router.
   *
   * @param {workbox-routing.Route} route The route to unregister.
   */
  unregisterRoute(route) {
    if (!this._routes.has(route.method)) {
      throw new WorkboxError("unregister-route-but-not-found-with-method", {
        method: route.method
      });
    }
    const routeIndex = this._routes.get(route.method).indexOf(route);
    if (routeIndex > -1) {
      this._routes.get(route.method).splice(routeIndex, 1);
    } else {
      throw new WorkboxError("unregister-route-route-not-registered");
    }
  }
}
let defaultRouter;
const getOrCreateDefaultRouter = () => {
  if (!defaultRouter) {
    defaultRouter = new Router();
    defaultRouter.addFetchListener();
    defaultRouter.addCacheListener();
  }
  return defaultRouter;
};
function registerRoute(capture, handler, method) {
  let route;
  if (typeof capture === "string") {
    const captureUrl = new URL(capture, location.href);
    const matchCallback = ({ url }) => {
      return url.href === captureUrl.href;
    };
    route = new Route(matchCallback, handler, method);
  } else if (capture instanceof RegExp) {
    route = new RegExpRoute(capture, handler, method);
  } else if (typeof capture === "function") {
    route = new Route(capture, handler, method);
  } else if (capture instanceof Route) {
    route = capture;
  } else {
    throw new WorkboxError("unsupported-route-type", {
      moduleName: "workbox-routing",
      funcName: "registerRoute",
      paramName: "capture"
    });
  }
  const defaultRouter2 = getOrCreateDefaultRouter();
  defaultRouter2.registerRoute(route);
  return route;
}
function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {
  for (const paramName of [...urlObject.searchParams.keys()]) {
    if (ignoreURLParametersMatching.some((regExp) => regExp.test(paramName))) {
      urlObject.searchParams.delete(paramName);
    }
  }
  return urlObject;
}
function* generateURLVariations(url, { ignoreURLParametersMatching = [/^utm_/, /^fbclid$/], directoryIndex = "index.html", cleanURLs = true, urlManipulation } = {}) {
  const urlObject = new URL(url, location.href);
  urlObject.hash = "";
  yield urlObject.href;
  const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);
  yield urlWithoutIgnoredParams.href;
  if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith("/")) {
    const directoryURL = new URL(urlWithoutIgnoredParams.href);
    directoryURL.pathname += directoryIndex;
    yield directoryURL.href;
  }
  if (cleanURLs) {
    const cleanURL = new URL(urlWithoutIgnoredParams.href);
    cleanURL.pathname += ".html";
    yield cleanURL.href;
  }
  if (urlManipulation) {
    const additionalURLs = urlManipulation({ url: urlObject });
    for (const urlToAttempt of additionalURLs) {
      yield urlToAttempt.href;
    }
  }
}
class PrecacheRoute extends Route {
  /**
   * @param {PrecacheController} precacheController A `PrecacheController`
   * instance used to both match requests and respond to fetch events.
   * @param {Object} [options] Options to control how requests are matched
   * against the list of precached URLs.
   * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will
   * check cache entries for a URLs ending with '/' to see if there is a hit when
   * appending the `directoryIndex` value.
   * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An
   * array of regex's to remove search params when looking for a cache match.
   * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will
   * check the cache for the URL with a `.html` added to the end of the end.
   * @param {workbox-precaching~urlManipulation} [options.urlManipulation]
   * This is a function that should take a URL and return an array of
   * alternative URLs that should be checked for precache matches.
   */
  constructor(precacheController2, options) {
    const match = ({ request }) => {
      const urlsToCacheKeys = precacheController2.getURLsToCacheKeys();
      for (const possibleURL of generateURLVariations(request.url, options)) {
        const cacheKey = urlsToCacheKeys.get(possibleURL);
        if (cacheKey) {
          const integrity = precacheController2.getIntegrityForCacheKey(cacheKey);
          return { cacheKey, integrity };
        }
      }
      return;
    };
    super(match, precacheController2.strategy);
  }
}
function addRoute(options) {
  const precacheController2 = getOrCreatePrecacheController();
  const precacheRoute = new PrecacheRoute(precacheController2, options);
  registerRoute(precacheRoute);
}
const SUBSTRING_TO_FIND = "-precache-";
const deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND) => {
  const cacheNames2 = await self.caches.keys();
  const cacheNamesToDelete = cacheNames2.filter((cacheName) => {
    return cacheName.includes(substringToFind) && cacheName.includes(self.registration.scope) && cacheName !== currentPrecacheName;
  });
  await Promise.all(cacheNamesToDelete.map((cacheName) => self.caches.delete(cacheName)));
  return cacheNamesToDelete;
};
function cleanupOutdatedCaches() {
  self.addEventListener("activate", (event) => {
    const cacheName = cacheNames.getPrecacheName();
    event.waitUntil(deleteOutdatedCaches(cacheName).then((cachesDeleted) => {
    }));
  });
}
function createHandlerBoundToURL(url) {
  const precacheController2 = getOrCreatePrecacheController();
  return precacheController2.createHandlerBoundToURL(url);
}
function precache(entries2) {
  const precacheController2 = getOrCreatePrecacheController();
  precacheController2.precache(entries2);
}
function precacheAndRoute(entries2, options) {
  precache(entries2);
  addRoute(options);
}
class NavigationRoute extends Route {
  /**
   * If both `denylist` and `allowlist` are provided, the `denylist` will
   * take precedence and the request will not match this route.
   *
   * The regular expressions in `allowlist` and `denylist`
   * are matched against the concatenated
   * [`pathname`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}
   * and [`search`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search}
   * portions of the requested URL.
   *
   * *Note*: These RegExps may be evaluated against every destination URL during
   * a navigation. Avoid using
   * [complex RegExps](https://github.com/GoogleChrome/workbox/issues/3077),
   * or else your users may see delays when navigating your site.
   *
   * @param {workbox-routing~handlerCallback} handler A callback
   * function that returns a Promise resulting in a Response.
   * @param {Object} options
   * @param {Array<RegExp>} [options.denylist] If any of these patterns match,
   * the route will not handle the request (even if a allowlist RegExp matches).
   * @param {Array<RegExp>} [options.allowlist=[/./]] If any of these patterns
   * match the URL's pathname and search parameter, the route will handle the
   * request (assuming the denylist doesn't match).
   */
  constructor(handler, { allowlist: allowlist2 = [/./], denylist = [] } = {}) {
    super((options) => this._match(options), handler);
    this._allowlist = allowlist2;
    this._denylist = denylist;
  }
  /**
   * Routes match handler.
   *
   * @param {Object} options
   * @param {URL} options.url
   * @param {Request} options.request
   * @return {boolean}
   *
   * @private
   */
  _match({ url, request }) {
    if (request && request.mode !== "navigate") {
      return false;
    }
    const pathnameAndSearch = url.pathname + url.search;
    for (const regExp of this._denylist) {
      if (regExp.test(pathnameAndSearch)) {
        return false;
      }
    }
    if (this._allowlist.some((regExp) => regExp.test(pathnameAndSearch))) {
      return true;
    }
    return false;
  }
}
const cacheOkAndOpaquePlugin = {
  /**
   * Returns a valid response (to allow caching) if the status is 200 (OK) or
   * 0 (opaque).
   *
   * @param {Object} options
   * @param {Response} options.response
   * @return {Response|null}
   *
   * @private
   */
  cacheWillUpdate: async ({ response }) => {
    if (response.status === 200 || response.status === 0) {
      return response;
    }
    return null;
  }
};
class NetworkFirst extends Strategy {
  /**
   * @param {Object} [options]
   * @param {string} [options.cacheName] Cache name to store and retrieve
   * requests. Defaults to cache names provided by
   * {@link workbox-core.cacheNames}.
   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
   * to use in conjunction with this caching strategy.
   * @param {Object} [options.fetchOptions] Values passed along to the
   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
   * `fetch()` requests made by this strategy.
   * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)
   * @param {number} [options.networkTimeoutSeconds] If set, any network requests
   * that fail to respond within the timeout will fallback to the cache.
   *
   * This option can be used to combat
   * "[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}"
   * scenarios.
   */
  constructor(options = {}) {
    super(options);
    if (!this.plugins.some((p) => "cacheWillUpdate" in p)) {
      this.plugins.unshift(cacheOkAndOpaquePlugin);
    }
    this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;
  }
  /**
   * @private
   * @param {Request|string} request A request to run this strategy for.
   * @param {workbox-strategies.StrategyHandler} handler The event that
   *     triggered the request.
   * @return {Promise<Response>}
   */
  async _handle(request, handler) {
    const logs = [];
    const promises = [];
    let timeoutId;
    if (this._networkTimeoutSeconds) {
      const { id, promise } = this._getTimeoutPromise({ request, logs, handler });
      timeoutId = id;
      promises.push(promise);
    }
    const networkPromise = this._getNetworkPromise({
      timeoutId,
      request,
      logs,
      handler
    });
    promises.push(networkPromise);
    const response = await handler.waitUntil((async () => {
      return await handler.waitUntil(Promise.race(promises)) || // If Promise.race() resolved with null, it might be due to a network
      // timeout + a cache miss. If that were to happen, we'd rather wait until
      // the networkPromise resolves instead of returning null.
      // Note that it's fine to await an already-resolved promise, so we don't
      // have to check to see if it's still "in flight".
      await networkPromise;
    })());
    if (!response) {
      throw new WorkboxError("no-response", { url: request.url });
    }
    return response;
  }
  /**
   * @param {Object} options
   * @param {Request} options.request
   * @param {Array} options.logs A reference to the logs array
   * @param {Event} options.event
   * @return {Promise<Response>}
   *
   * @private
   */
  _getTimeoutPromise({ request, logs, handler }) {
    let timeoutId;
    const timeoutPromise = new Promise((resolve) => {
      const onNetworkTimeout = async () => {
        resolve(await handler.cacheMatch(request));
      };
      timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1e3);
    });
    return {
      promise: timeoutPromise,
      id: timeoutId
    };
  }
  /**
   * @param {Object} options
   * @param {number|undefined} options.timeoutId
   * @param {Request} options.request
   * @param {Array} options.logs A reference to the logs Array.
   * @param {Event} options.event
   * @return {Promise<Response>}
   *
   * @private
   */
  async _getNetworkPromise({ timeoutId, request, logs, handler }) {
    let error;
    let response;
    try {
      response = await handler.fetchAndCachePut(request);
    } catch (fetchError) {
      if (fetchError instanceof Error) {
        error = fetchError;
      }
    }
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    if (error || !response) {
      response = await handler.cacheMatch(request);
    }
    return response;
  }
}
class NetworkOnly extends Strategy {
  /**
   * @param {Object} [options]
   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
   * to use in conjunction with this caching strategy.
   * @param {Object} [options.fetchOptions] Values passed along to the
   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
   * `fetch()` requests made by this strategy.
   * @param {number} [options.networkTimeoutSeconds] If set, any network requests
   * that fail to respond within the timeout will result in a network error.
   */
  constructor(options = {}) {
    super(options);
    this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;
  }
  /**
   * @private
   * @param {Request|string} request A request to run this strategy for.
   * @param {workbox-strategies.StrategyHandler} handler The event that
   *     triggered the request.
   * @return {Promise<Response>}
   */
  async _handle(request, handler) {
    let error = void 0;
    let response;
    try {
      const promises = [
        handler.fetch(request)
      ];
      if (this._networkTimeoutSeconds) {
        const timeoutPromise = timeout(this._networkTimeoutSeconds * 1e3);
        promises.push(timeoutPromise);
      }
      response = await Promise.race(promises);
      if (!response) {
        throw new Error(`Timed out the network response after ${this._networkTimeoutSeconds} seconds.`);
      }
    } catch (err) {
      if (err instanceof Error) {
        error = err;
      }
    }
    if (!response) {
      throw new WorkboxError("no-response", { url: request.url, error });
    }
    return response;
  }
}
class StaleWhileRevalidate extends Strategy {
  /**
   * @param {Object} [options]
   * @param {string} [options.cacheName] Cache name to store and retrieve
   * requests. Defaults to cache names provided by
   * {@link workbox-core.cacheNames}.
   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
   * to use in conjunction with this caching strategy.
   * @param {Object} [options.fetchOptions] Values passed along to the
   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
   * `fetch()` requests made by this strategy.
   * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)
   */
  constructor(options = {}) {
    super(options);
    if (!this.plugins.some((p) => "cacheWillUpdate" in p)) {
      this.plugins.unshift(cacheOkAndOpaquePlugin);
    }
  }
  /**
   * @private
   * @param {Request|string} request A request to run this strategy for.
   * @param {workbox-strategies.StrategyHandler} handler The event that
   *     triggered the request.
   * @return {Promise<Response>}
   */
  async _handle(request, handler) {
    const fetchAndCachePromise = handler.fetchAndCachePut(request).catch(() => {
    });
    void handler.waitUntil(fetchAndCachePromise);
    let response = await handler.cacheMatch(request);
    let error;
    if (response) ;
    else {
      try {
        response = await fetchAndCachePromise;
      } catch (err) {
        if (err instanceof Error) {
          error = err;
        }
      }
    }
    if (!response) {
      throw new WorkboxError("no-response", { url: request.url, error });
    }
    return response;
  }
}
const entries = [{"revision":"3419fdfe17cd7cbc423783667ce33427","url":"404.html"},{"revision":"c7c8cd9880c73ca1ff257be6801721f5","url":"add-ons.html"},{"revision":"92fcd6e3fad3355cdca56cd66f106831","url":"apple-touch-icon.png"},{"revision":null,"url":"assets/add-ons.md.BfN5_YoR.js"},{"revision":null,"url":"assets/add-ons.md.BfN5_YoR.lean.js"},{"revision":null,"url":"assets/app.CbwzQgZi.js"},{"revision":null,"url":"assets/chunks/@localSearchIndexroot.D6LnUkif.js"},{"revision":null,"url":"assets/chunks/axios.Dpq17vxx.js"},{"revision":null,"url":"assets/chunks/BooleanDisplay.JwC9osdQ.js"},{"revision":null,"url":"assets/chunks/browser.Bfe5jVnv.js"},{"revision":null,"url":"assets/chunks/CodeToggle.Cln1dxXk.js"},{"revision":null,"url":"assets/chunks/computedAsync.BT2aHUPK.js"},{"revision":null,"url":"assets/chunks/configurable.DuBTHq8T.js"},{"revision":null,"url":"assets/chunks/Contributors.CX10SFbe.js"},{"revision":null,"url":"assets/chunks/CourseLink.DwmkPr5U.js"},{"revision":null,"url":"assets/chunks/createEventHook.DjKBYIH4.js"},{"revision":null,"url":"assets/chunks/demo.client.2OZD3pIx.js"},{"revision":null,"url":"assets/chunks/demo.client.B7HUleWq.js"},{"revision":null,"url":"assets/chunks/demo.client.BgJCbOOF.js"},{"revision":null,"url":"assets/chunks/demo.client.C5uQD6ix.js"},{"revision":null,"url":"assets/chunks/demo.client.kAuy9FoK.js"},{"revision":null,"url":"assets/chunks/DemoContainer.SVKxL57n.js"},{"revision":null,"url":"assets/chunks/filters.CUMa_U49.js"},{"revision":null,"url":"assets/chunks/FunctionInfo.EuFHdlpO.js"},{"revision":null,"url":"assets/chunks/fuse.B_9XegHF.js"},{"revision":null,"url":"assets/chunks/general.CPMlYMV9.js"},{"revision":null,"url":"assets/chunks/injectLocal.D06jyxEv.js"},{"revision":null,"url":"assets/chunks/is.J6NoNqY_.js"},{"revision":null,"url":"assets/chunks/jsx-Bg-IJ-oD.BQXVZKaN.js"},{"revision":null,"url":"assets/chunks/metadata.DQnShKqh.js"},{"revision":null,"url":"assets/chunks/Note.Cl_KglIg.js"},{"revision":null,"url":"assets/chunks/onClickOutside.CzfMfNMb.js"},{"revision":null,"url":"assets/chunks/onElementRemoval.D5YdJ-Go.js"},{"revision":null,"url":"assets/chunks/onKeyStroke.CYw-tkMC.js"},{"revision":null,"url":"assets/chunks/onStartTyping.CL6Vt38n.js"},{"revision":null,"url":"assets/chunks/plugin-vue_export-helper.BDn6UvXA.js"},{"revision":null,"url":"assets/chunks/resolve-element.Cf2gzP5G.js"},{"revision":null,"url":"assets/chunks/rolldown-runtime.6nYsG-iV.js"},{"revision":null,"url":"assets/chunks/Scrubber.H0Kusql8.js"},{"revision":null,"url":"assets/chunks/syncRef.WKZSMv_f.js"},{"revision":null,"url":"assets/chunks/toRef.BNr2Rxs5.js"},{"revision":null,"url":"assets/chunks/toRefs.iHw9oI1g.js"},{"revision":null,"url":"assets/chunks/tryOnMounted.CJs_r5qD.js"},{"revision":null,"url":"assets/chunks/tryOnScopeDispose.52c2sqvU.js"},{"revision":null,"url":"assets/chunks/tryOnUnmounted._UPw53qq.js"},{"revision":null,"url":"assets/chunks/unrefElement.BPPQrlgs.js"},{"revision":null,"url":"assets/chunks/until.B-zpBbFI.js"},{"revision":null,"url":"assets/chunks/useActiveElement.b1vt5IFx.js"},{"revision":null,"url":"assets/chunks/useAsyncState.CHiDjM2I.js"},{"revision":null,"url":"assets/chunks/useClamp.DN2fIUNE.js"},{"revision":null,"url":"assets/chunks/useCloned.ZW3Yyp73.js"},{"revision":null,"url":"assets/chunks/useColorMode.ch4fD5y6.js"},{"revision":null,"url":"assets/chunks/useCounter.CUfMKmhu.js"},{"revision":null,"url":"assets/chunks/useCssVar.CUNilzh2.js"},{"revision":null,"url":"assets/chunks/useCurrentElement.BGBjbMiC.js"},{"revision":null,"url":"assets/chunks/useCycleList.Dtua5R2t.js"},{"revision":null,"url":"assets/chunks/useDark.CGUjwT_m.js"},{"revision":null,"url":"assets/chunks/useDateFormat.C59ARL2D.js"},{"revision":null,"url":"assets/chunks/useDebounceFn.Q7sSphRD.js"},{"revision":null,"url":"assets/chunks/useDeviceOrientation.UAGGFFBx.js"},{"revision":null,"url":"assets/chunks/useDevicesList.i0atKB1g.js"},{"revision":null,"url":"assets/chunks/useDocumentVisibility.uBK8-uvy.js"},{"revision":null,"url":"assets/chunks/useElementBounding.B47xa0cY.js"},{"revision":null,"url":"assets/chunks/useElementByPoint.CG4ccE4P.js"},{"revision":null,"url":"assets/chunks/useElementSize.Ce8O9TmT.js"},{"revision":null,"url":"assets/chunks/useElementVisibility.Cts6ySJW.js"},{"revision":null,"url":"assets/chunks/useEventListener.Cti38iiT.js"},{"revision":null,"url":"assets/chunks/useFocusTrap.DusxPzqr.js"},{"revision":null,"url":"assets/chunks/useIntersectionObserver.Da7-sIga.js"},{"revision":null,"url":"assets/chunks/useManualRefHistory.B_IZJ46T.js"},{"revision":null,"url":"assets/chunks/useMediaQuery.ccNFVciy.js"},{"revision":null,"url":"assets/chunks/useMounted.CuhcSusG.js"},{"revision":null,"url":"assets/chunks/useMouse.VqTr8Xic.js"},{"revision":null,"url":"assets/chunks/useMouseInElement.DRBTTTYd.js"},{"revision":null,"url":"assets/chunks/useMutationObserver.DOVZgknu.js"},{"revision":null,"url":"assets/chunks/useNetwork.DG8pVQuV.js"},{"revision":null,"url":"assets/chunks/useParentElement.Fyx-h3PX.js"},{"revision":null,"url":"assets/chunks/usePermission.Cb9ShUJz.js"},{"revision":null,"url":"assets/chunks/usePreferredDark.CFRlfpCX.js"},{"revision":null,"url":"assets/chunks/useRafFn.BeeOZqzG.js"},{"revision":null,"url":"assets/chunks/useRefHistory.D6kSPRNS.js"},{"revision":null,"url":"assets/chunks/useResizeObserver.2Bn_6B5_.js"},{"revision":null,"url":"assets/chunks/useScreenOrientation.jy0CtwPU.js"},{"revision":null,"url":"assets/chunks/useScroll.B_sgaQf9.js"},{"revision":null,"url":"assets/chunks/useScrollLock.C9kF6hor.js"},{"revision":null,"url":"assets/chunks/useStorage.DkJc_SLf.js"},{"revision":null,"url":"assets/chunks/useSupported.O3lMHp1K.js"},{"revision":null,"url":"assets/chunks/useThrottleFn.C672lu5Q.js"},{"revision":null,"url":"assets/chunks/useTimeoutFn.BeDhJsen.js"},{"revision":null,"url":"assets/chunks/useTimestamp.CpZZ2mKn.js"},{"revision":null,"url":"assets/chunks/useToggle.zoboSgJO.js"},{"revision":null,"url":"assets/chunks/useUrlSearchParams.p5ZB46s5.js"},{"revision":null,"url":"assets/chunks/useWindowScroll.BuOYzXMG.js"},{"revision":null,"url":"assets/chunks/useWindowSize.JFGhDHlJ.js"},{"revision":null,"url":"assets/chunks/utils.CiYclqL1.js"},{"revision":null,"url":"assets/chunks/VPLocalSearchBox.DlA9C1u9.js"},{"revision":null,"url":"assets/chunks/vue.DLm9j74-.js"},{"revision":null,"url":"assets/chunks/watchDebounced.BB2qBfBJ.js"},{"revision":null,"url":"assets/chunks/watchIgnorable.Dwp8rZMU.js"},{"revision":null,"url":"assets/chunks/watchPausable.C0q9cU2I.js"},{"revision":null,"url":"assets/chunks/watchWithFilter.DZ5NXp2w.js"},{"revision":null,"url":"assets/components_README.md.f7VhimOj.js"},{"revision":null,"url":"assets/components_README.md.f7VhimOj.lean.js"},{"revision":null,"url":"assets/contributing.md.BbcMuaLn.js"},{"revision":null,"url":"assets/contributing.md.BbcMuaLn.lean.js"},{"revision":null,"url":"assets/core__template_index.md.rb2u-FU1.js"},{"revision":null,"url":"assets/core__template_index.md.rb2u-FU1.lean.js"},{"revision":null,"url":"assets/core_computedAsync_index.md.J0xqWEbn.js"},{"revision":null,"url":"assets/core_computedAsync_index.md.J0xqWEbn.lean.js"},{"revision":null,"url":"assets/core_computedInject_index.md.Dh6stolm.js"},{"revision":null,"url":"assets/core_computedInject_index.md.Dh6stolm.lean.js"},{"revision":null,"url":"assets/core_createReusableTemplate_index.md.CiH0hGIN.js"},{"revision":null,"url":"assets/core_createReusableTemplate_index.md.CiH0hGIN.lean.js"},{"revision":null,"url":"assets/core_createTemplatePromise_index.md.lA5GoOsj.js"},{"revision":null,"url":"assets/core_createTemplatePromise_index.md.lA5GoOsj.lean.js"},{"revision":null,"url":"assets/core_createUnrefFn_index.md.CUu-TKoV.js"},{"revision":null,"url":"assets/core_createUnrefFn_index.md.CUu-TKoV.lean.js"},{"revision":null,"url":"assets/core_onClickOutside_index.md.BFqkU6Fu.js"},{"revision":null,"url":"assets/core_onClickOutside_index.md.BFqkU6Fu.lean.js"},{"revision":null,"url":"assets/core_onElementRemoval_index.md.B9CMIdHf.js"},{"revision":null,"url":"assets/core_onElementRemoval_index.md.B9CMIdHf.lean.js"},{"revision":null,"url":"assets/core_onKeyStroke_index.md.92MfKDJ1.js"},{"revision":null,"url":"assets/core_onKeyStroke_index.md.92MfKDJ1.lean.js"},{"revision":null,"url":"assets/core_onLongPress_index.md.nOYJD79i.js"},{"revision":null,"url":"assets/core_onLongPress_index.md.nOYJD79i.lean.js"},{"revision":null,"url":"assets/core_onStartTyping_index.md.C64bDGAZ.js"},{"revision":null,"url":"assets/core_onStartTyping_index.md.C64bDGAZ.lean.js"},{"revision":null,"url":"assets/core_README.md.Dh_ABX0C.js"},{"revision":null,"url":"assets/core_README.md.Dh_ABX0C.lean.js"},{"revision":null,"url":"assets/core_templateRef_index.md.i5BRfrlS.js"},{"revision":null,"url":"assets/core_templateRef_index.md.i5BRfrlS.lean.js"},{"revision":null,"url":"assets/core_unrefElement_index.md.BQhoY3tk.js"},{"revision":null,"url":"assets/core_unrefElement_index.md.BQhoY3tk.lean.js"},{"revision":null,"url":"assets/core_useActiveElement_index.md.Saoi0vyh.js"},{"revision":null,"url":"assets/core_useActiveElement_index.md.Saoi0vyh.lean.js"},{"revision":null,"url":"assets/core_useAnimate_index.md.CyFK5nR7.js"},{"revision":null,"url":"assets/core_useAnimate_index.md.CyFK5nR7.lean.js"},{"revision":null,"url":"assets/core_useAsyncQueue_index.md.DMHlH6yw.js"},{"revision":null,"url":"assets/core_useAsyncQueue_index.md.DMHlH6yw.lean.js"},{"revision":null,"url":"assets/core_useAsyncState_index.md.CUS-BaID.js"},{"revision":null,"url":"assets/core_useAsyncState_index.md.CUS-BaID.lean.js"},{"revision":null,"url":"assets/core_useBase64_index.md.B8bKTEEq.js"},{"revision":null,"url":"assets/core_useBase64_index.md.B8bKTEEq.lean.js"},{"revision":null,"url":"assets/core_useBattery_index.md.DuvjC2Q3.js"},{"revision":null,"url":"assets/core_useBattery_index.md.DuvjC2Q3.lean.js"},{"revision":null,"url":"assets/core_useBluetooth_index.md.Boq3wP7x.js"},{"revision":null,"url":"assets/core_useBluetooth_index.md.Boq3wP7x.lean.js"},{"revision":null,"url":"assets/core_useBreakpoints_index.md.Dw-854Bl.js"},{"revision":null,"url":"assets/core_useBreakpoints_index.md.Dw-854Bl.lean.js"},{"revision":null,"url":"assets/core_useBroadcastChannel_index.md.B6h-LvuS.js"},{"revision":null,"url":"assets/core_useBroadcastChannel_index.md.B6h-LvuS.lean.js"},{"revision":null,"url":"assets/core_useBrowserLocation_index.md.BtTkpvFy.js"},{"revision":null,"url":"assets/core_useBrowserLocation_index.md.BtTkpvFy.lean.js"},{"revision":null,"url":"assets/core_useCached_index.md.C1NkIoPD.js"},{"revision":null,"url":"assets/core_useCached_index.md.C1NkIoPD.lean.js"},{"revision":null,"url":"assets/core_useClipboard_index.md.BPB6EXmN.js"},{"revision":null,"url":"assets/core_useClipboard_index.md.BPB6EXmN.lean.js"},{"revision":null,"url":"assets/core_useClipboardItems_index.md.C8eVSLGN.js"},{"revision":null,"url":"assets/core_useClipboardItems_index.md.C8eVSLGN.lean.js"},{"revision":null,"url":"assets/core_useCloned_index.md.BDqubm64.js"},{"revision":null,"url":"assets/core_useCloned_index.md.BDqubm64.lean.js"},{"revision":null,"url":"assets/core_useColorMode_index.md.CyQd0oDQ.js"},{"revision":null,"url":"assets/core_useColorMode_index.md.CyQd0oDQ.lean.js"},{"revision":null,"url":"assets/core_useConfirmDialog_index.md.C55xZSau.js"},{"revision":null,"url":"assets/core_useConfirmDialog_index.md.C55xZSau.lean.js"},{"revision":null,"url":"assets/core_useCountdown_index.md.BKIGa8iH.js"},{"revision":null,"url":"assets/core_useCountdown_index.md.BKIGa8iH.lean.js"},{"revision":null,"url":"assets/core_useCssVar_index.md.Ch14EHVI.js"},{"revision":null,"url":"assets/core_useCssVar_index.md.Ch14EHVI.lean.js"},{"revision":null,"url":"assets/core_useCurrentElement_index.md.tMOU2wwV.js"},{"revision":null,"url":"assets/core_useCurrentElement_index.md.tMOU2wwV.lean.js"},{"revision":null,"url":"assets/core_useCycleList_index.md.CF9gB19i.js"},{"revision":null,"url":"assets/core_useCycleList_index.md.CF9gB19i.lean.js"},{"revision":null,"url":"assets/core_useDark_index.md.CqFLkE4B.js"},{"revision":null,"url":"assets/core_useDark_index.md.CqFLkE4B.lean.js"},{"revision":null,"url":"assets/core_useDebouncedRefHistory_index.md.BYhN6uYp.js"},{"revision":null,"url":"assets/core_useDebouncedRefHistory_index.md.BYhN6uYp.lean.js"},{"revision":null,"url":"assets/core_useDeviceMotion_index.md.CDicn2Vn.js"},{"revision":null,"url":"assets/core_useDeviceMotion_index.md.CDicn2Vn.lean.js"},{"revision":null,"url":"assets/core_useDeviceOrientation_index.md.4fUlH15j.js"},{"revision":null,"url":"assets/core_useDeviceOrientation_index.md.4fUlH15j.lean.js"},{"revision":null,"url":"assets/core_useDevicePixelRatio_index.md.D2ggaZss.js"},{"revision":null,"url":"assets/core_useDevicePixelRatio_index.md.D2ggaZss.lean.js"},{"revision":null,"url":"assets/core_useDevicesList_index.md.BW8J5__9.js"},{"revision":null,"url":"assets/core_useDevicesList_index.md.BW8J5__9.lean.js"},{"revision":null,"url":"assets/core_useDisplayMedia_index.md.LNSrFTaH.js"},{"revision":null,"url":"assets/core_useDisplayMedia_index.md.LNSrFTaH.lean.js"},{"revision":null,"url":"assets/core_useDocumentVisibility_index.md.eTndWwNb.js"},{"revision":null,"url":"assets/core_useDocumentVisibility_index.md.eTndWwNb.lean.js"},{"revision":null,"url":"assets/core_useDraggable_index.md.DlCk3aG2.js"},{"revision":null,"url":"assets/core_useDraggable_index.md.DlCk3aG2.lean.js"},{"revision":null,"url":"assets/core_useDropZone_index.md.BBE2kPxU.js"},{"revision":null,"url":"assets/core_useDropZone_index.md.BBE2kPxU.lean.js"},{"revision":null,"url":"assets/core_useElementBounding_index.md.C01G3Nhx.js"},{"revision":null,"url":"assets/core_useElementBounding_index.md.C01G3Nhx.lean.js"},{"revision":null,"url":"assets/core_useElementByPoint_index.md.juR7f5ZE.js"},{"revision":null,"url":"assets/core_useElementByPoint_index.md.juR7f5ZE.lean.js"},{"revision":null,"url":"assets/core_useElementHover_index.md.DyHwuSbj.js"},{"revision":null,"url":"assets/core_useElementHover_index.md.DyHwuSbj.lean.js"},{"revision":null,"url":"assets/core_useElementSize_index.md.ZQfpBUQV.js"},{"revision":null,"url":"assets/core_useElementSize_index.md.ZQfpBUQV.lean.js"},{"revision":null,"url":"assets/core_useElementVisibility_index.md.WWMLf5dX.js"},{"revision":null,"url":"assets/core_useElementVisibility_index.md.WWMLf5dX.lean.js"},{"revision":null,"url":"assets/core_useEventBus_index.md.Pm026mLT.js"},{"revision":null,"url":"assets/core_useEventBus_index.md.Pm026mLT.lean.js"},{"revision":null,"url":"assets/core_useEventListener_index.md.jMOo2WkD.js"},{"revision":null,"url":"assets/core_useEventListener_index.md.jMOo2WkD.lean.js"},{"revision":null,"url":"assets/core_useEventSource_index.md.DaIcfW8c.js"},{"revision":null,"url":"assets/core_useEventSource_index.md.DaIcfW8c.lean.js"},{"revision":null,"url":"assets/core_useEyeDropper_index.md.CV2hTcLf.js"},{"revision":null,"url":"assets/core_useEyeDropper_index.md.CV2hTcLf.lean.js"},{"revision":null,"url":"assets/core_useFavicon_index.md.vV-wjHNj.js"},{"revision":null,"url":"assets/core_useFavicon_index.md.vV-wjHNj.lean.js"},{"revision":null,"url":"assets/core_useFetch_index.md.BtniI7LL.js"},{"revision":null,"url":"assets/core_useFetch_index.md.BtniI7LL.lean.js"},{"revision":null,"url":"assets/core_useFileDialog_index.md.DishWitO.js"},{"revision":null,"url":"assets/core_useFileDialog_index.md.DishWitO.lean.js"},{"revision":null,"url":"assets/core_useFileSystemAccess_index.md.HuKp4Hry.js"},{"revision":null,"url":"assets/core_useFileSystemAccess_index.md.HuKp4Hry.lean.js"},{"revision":null,"url":"assets/core_useFocus_index.md.Bb69Wz90.js"},{"revision":null,"url":"assets/core_useFocus_index.md.Bb69Wz90.lean.js"},{"revision":null,"url":"assets/core_useFocusWithin_index.md.DDW3Gdwa.js"},{"revision":null,"url":"assets/core_useFocusWithin_index.md.DDW3Gdwa.lean.js"},{"revision":null,"url":"assets/core_useFps_index.md.BXpTUbw9.js"},{"revision":null,"url":"assets/core_useFps_index.md.BXpTUbw9.lean.js"},{"revision":null,"url":"assets/core_useFullscreen_index.md.0l0s3JpG.js"},{"revision":null,"url":"assets/core_useFullscreen_index.md.0l0s3JpG.lean.js"},{"revision":null,"url":"assets/core_useGamepad_index.md.DlfvsaXC.js"},{"revision":null,"url":"assets/core_useGamepad_index.md.DlfvsaXC.lean.js"},{"revision":null,"url":"assets/core_useGeolocation_index.md.DhrIsHqh.js"},{"revision":null,"url":"assets/core_useGeolocation_index.md.DhrIsHqh.lean.js"},{"revision":null,"url":"assets/core_useIdle_index.md.BV8sz5qb.js"},{"revision":null,"url":"assets/core_useIdle_index.md.BV8sz5qb.lean.js"},{"revision":null,"url":"assets/core_useImage_index.md.D_MsUY9F.js"},{"revision":null,"url":"assets/core_useImage_index.md.D_MsUY9F.lean.js"},{"revision":null,"url":"assets/core_useInfiniteScroll_index.md.3HTGP4qs.js"},{"revision":null,"url":"assets/core_useInfiniteScroll_index.md.3HTGP4qs.lean.js"},{"revision":null,"url":"assets/core_useIntersectionObserver_index.md.DHHP8jH5.js"},{"revision":null,"url":"assets/core_useIntersectionObserver_index.md.DHHP8jH5.lean.js"},{"revision":null,"url":"assets/core_useKeyModifier_index.md.DM8mNV_B.js"},{"revision":null,"url":"assets/core_useKeyModifier_index.md.DM8mNV_B.lean.js"},{"revision":null,"url":"assets/core_useLocalStorage_index.md.C5ibkHqs.js"},{"revision":null,"url":"assets/core_useLocalStorage_index.md.C5ibkHqs.lean.js"},{"revision":null,"url":"assets/core_useMagicKeys_index.md.zAh4JxGi.js"},{"revision":null,"url":"assets/core_useMagicKeys_index.md.zAh4JxGi.lean.js"},{"revision":null,"url":"assets/core_useManualRefHistory_index.md.DOes5mT6.js"},{"revision":null,"url":"assets/core_useManualRefHistory_index.md.DOes5mT6.lean.js"},{"revision":null,"url":"assets/core_useMediaControls_index.md.DVSExrUz.js"},{"revision":null,"url":"assets/core_useMediaControls_index.md.DVSExrUz.lean.js"},{"revision":null,"url":"assets/core_useMediaQuery_index.md.BX5qk_p8.js"},{"revision":null,"url":"assets/core_useMediaQuery_index.md.BX5qk_p8.lean.js"},{"revision":null,"url":"assets/core_useMemoize_index.md.ClJ9K0Va.js"},{"revision":null,"url":"assets/core_useMemoize_index.md.ClJ9K0Va.lean.js"},{"revision":null,"url":"assets/core_useMemory_index.md.YFPEURKf.js"},{"revision":null,"url":"assets/core_useMemory_index.md.YFPEURKf.lean.js"},{"revision":null,"url":"assets/core_useMounted_index.md.DC02iD6P.js"},{"revision":null,"url":"assets/core_useMounted_index.md.DC02iD6P.lean.js"},{"revision":null,"url":"assets/core_useMouse_index.md.Cs1XbRXv.js"},{"revision":null,"url":"assets/core_useMouse_index.md.Cs1XbRXv.lean.js"},{"revision":null,"url":"assets/core_useMouseInElement_index.md.CYaPIKFh.js"},{"revision":null,"url":"assets/core_useMouseInElement_index.md.CYaPIKFh.lean.js"},{"revision":null,"url":"assets/core_useMousePressed_index.md.Ei6ADG7z.js"},{"revision":null,"url":"assets/core_useMousePressed_index.md.Ei6ADG7z.lean.js"},{"revision":null,"url":"assets/core_useMutationObserver_index.md.UgEE3_WB.js"},{"revision":null,"url":"assets/core_useMutationObserver_index.md.UgEE3_WB.lean.js"},{"revision":null,"url":"assets/core_useNavigatorLanguage_index.md.DaEWLWwV.js"},{"revision":null,"url":"assets/core_useNavigatorLanguage_index.md.DaEWLWwV.lean.js"},{"revision":null,"url":"assets/core_useNetwork_index.md.V99zmGXW.js"},{"revision":null,"url":"assets/core_useNetwork_index.md.V99zmGXW.lean.js"},{"revision":null,"url":"assets/core_useNow_index.md.D-TsNVrL.js"},{"revision":null,"url":"assets/core_useNow_index.md.D-TsNVrL.lean.js"},{"revision":null,"url":"assets/core_useObjectUrl_index.md.DqANPd3x.js"},{"revision":null,"url":"assets/core_useObjectUrl_index.md.DqANPd3x.lean.js"},{"revision":null,"url":"assets/core_useOffsetPagination_index.md.CXjubnfA.js"},{"revision":null,"url":"assets/core_useOffsetPagination_index.md.CXjubnfA.lean.js"},{"revision":null,"url":"assets/core_useOnline_index.md.CyAK8PTp.js"},{"revision":null,"url":"assets/core_useOnline_index.md.CyAK8PTp.lean.js"},{"revision":null,"url":"assets/core_usePageLeave_index.md.zjQyU8Ui.js"},{"revision":null,"url":"assets/core_usePageLeave_index.md.zjQyU8Ui.lean.js"},{"revision":null,"url":"assets/core_useParallax_index.md.BcEFkaXt.js"},{"revision":null,"url":"assets/core_useParallax_index.md.BcEFkaXt.lean.js"},{"revision":null,"url":"assets/core_useParentElement_index.md.B0Uzu2ON.js"},{"revision":null,"url":"assets/core_useParentElement_index.md.B0Uzu2ON.lean.js"},{"revision":null,"url":"assets/core_usePerformanceObserver_index.md.D5VGp3zc.js"},{"revision":null,"url":"assets/core_usePerformanceObserver_index.md.D5VGp3zc.lean.js"},{"revision":null,"url":"assets/core_usePermission_index.md.CbdqC51C.js"},{"revision":null,"url":"assets/core_usePermission_index.md.CbdqC51C.lean.js"},{"revision":null,"url":"assets/core_usePointer_index.md.CeO58kVG.js"},{"revision":null,"url":"assets/core_usePointer_index.md.CeO58kVG.lean.js"},{"revision":null,"url":"assets/core_usePointerLock_index.md.DswCsOIY.js"},{"revision":null,"url":"assets/core_usePointerLock_index.md.DswCsOIY.lean.js"},{"revision":null,"url":"assets/core_usePointerSwipe_index.md.xEoBacdg.js"},{"revision":null,"url":"assets/core_usePointerSwipe_index.md.xEoBacdg.lean.js"},{"revision":null,"url":"assets/core_usePreferredColorScheme_index.md.CciXmT3H.js"},{"revision":null,"url":"assets/core_usePreferredColorScheme_index.md.CciXmT3H.lean.js"},{"revision":null,"url":"assets/core_usePreferredContrast_index.md.hH81ysnZ.js"},{"revision":null,"url":"assets/core_usePreferredContrast_index.md.hH81ysnZ.lean.js"},{"revision":null,"url":"assets/core_usePreferredDark_index.md.CVDmX3be.js"},{"revision":null,"url":"assets/core_usePreferredDark_index.md.CVDmX3be.lean.js"},{"revision":null,"url":"assets/core_usePreferredLanguages_index.md.AdgwTZ2w.js"},{"revision":null,"url":"assets/core_usePreferredLanguages_index.md.AdgwTZ2w.lean.js"},{"revision":null,"url":"assets/core_usePreferredReducedMotion_index.md.4deLQQ0P.js"},{"revision":null,"url":"assets/core_usePreferredReducedMotion_index.md.4deLQQ0P.lean.js"},{"revision":null,"url":"assets/core_usePreferredReducedTransparency_index.md.bB7tM15X.js"},{"revision":null,"url":"assets/core_usePreferredReducedTransparency_index.md.bB7tM15X.lean.js"},{"revision":null,"url":"assets/core_usePrevious_index.md.CZH8eaaG.js"},{"revision":null,"url":"assets/core_usePrevious_index.md.CZH8eaaG.lean.js"},{"revision":null,"url":"assets/core_useRafFn_index.md.DGmDb9Cv.js"},{"revision":null,"url":"assets/core_useRafFn_index.md.DGmDb9Cv.lean.js"},{"revision":null,"url":"assets/core_useRefHistory_index.md.DZClNrB5.js"},{"revision":null,"url":"assets/core_useRefHistory_index.md.DZClNrB5.lean.js"},{"revision":null,"url":"assets/core_useResizeObserver_index.md.BnTy86AL.js"},{"revision":null,"url":"assets/core_useResizeObserver_index.md.BnTy86AL.lean.js"},{"revision":null,"url":"assets/core_useScreenOrientation_index.md.UNmcvaFJ.js"},{"revision":null,"url":"assets/core_useScreenOrientation_index.md.UNmcvaFJ.lean.js"},{"revision":null,"url":"assets/core_useScreenSafeArea_index.md.BOaoMqiC.js"},{"revision":null,"url":"assets/core_useScreenSafeArea_index.md.BOaoMqiC.lean.js"},{"revision":null,"url":"assets/core_useScriptTag_index.md.BFYXMAvl.js"},{"revision":null,"url":"assets/core_useScriptTag_index.md.BFYXMAvl.lean.js"},{"revision":null,"url":"assets/core_useScroll_index.md.1Te05Fo0.js"},{"revision":null,"url":"assets/core_useScroll_index.md.1Te05Fo0.lean.js"},{"revision":null,"url":"assets/core_useScrollLock_index.md.C0hqIN8K.js"},{"revision":null,"url":"assets/core_useScrollLock_index.md.C0hqIN8K.lean.js"},{"revision":null,"url":"assets/core_useSessionStorage_index.md.BfHEYkNB.js"},{"revision":null,"url":"assets/core_useSessionStorage_index.md.BfHEYkNB.lean.js"},{"revision":null,"url":"assets/core_useShare_index.md.D-5G6ACi.js"},{"revision":null,"url":"assets/core_useShare_index.md.D-5G6ACi.lean.js"},{"revision":null,"url":"assets/core_useSorted_index.md.XbOXm3UJ.js"},{"revision":null,"url":"assets/core_useSorted_index.md.XbOXm3UJ.lean.js"},{"revision":null,"url":"assets/core_useSpeechRecognition_index.md.CRz9w7z7.js"},{"revision":null,"url":"assets/core_useSpeechRecognition_index.md.CRz9w7z7.lean.js"},{"revision":null,"url":"assets/core_useSpeechSynthesis_index.md.BtRcaOkh.js"},{"revision":null,"url":"assets/core_useSpeechSynthesis_index.md.BtRcaOkh.lean.js"},{"revision":null,"url":"assets/core_useSSRWidth_index.md.ChiyzJjR.js"},{"revision":null,"url":"assets/core_useSSRWidth_index.md.ChiyzJjR.lean.js"},{"revision":null,"url":"assets/core_useStepper_index.md.BWZW5_-7.js"},{"revision":null,"url":"assets/core_useStepper_index.md.BWZW5_-7.lean.js"},{"revision":null,"url":"assets/core_useStorage_index.md.DhCNqPge.js"},{"revision":null,"url":"assets/core_useStorage_index.md.DhCNqPge.lean.js"},{"revision":null,"url":"assets/core_useStorageAsync_index.md.DPLZqan4.js"},{"revision":null,"url":"assets/core_useStorageAsync_index.md.DPLZqan4.lean.js"},{"revision":null,"url":"assets/core_useStyleTag_index.md.BVjtHvO2.js"},{"revision":null,"url":"assets/core_useStyleTag_index.md.BVjtHvO2.lean.js"},{"revision":null,"url":"assets/core_useSupported_index.md.CR_aiOPg.js"},{"revision":null,"url":"assets/core_useSupported_index.md.CR_aiOPg.lean.js"},{"revision":null,"url":"assets/core_useSwipe_index.md.B4zgVQub.js"},{"revision":null,"url":"assets/core_useSwipe_index.md.B4zgVQub.lean.js"},{"revision":null,"url":"assets/core_useTemplateRefsList_index.md.D7N3BmAc.js"},{"revision":null,"url":"assets/core_useTemplateRefsList_index.md.D7N3BmAc.lean.js"},{"revision":null,"url":"assets/core_useTextareaAutosize_index.md.C1KvWfE3.js"},{"revision":null,"url":"assets/core_useTextareaAutosize_index.md.C1KvWfE3.lean.js"},{"revision":null,"url":"assets/core_useTextDirection_index.md.DT-vBPFd.js"},{"revision":null,"url":"assets/core_useTextDirection_index.md.DT-vBPFd.lean.js"},{"revision":null,"url":"assets/core_useTextSelection_index.md.BnXfAZay.js"},{"revision":null,"url":"assets/core_useTextSelection_index.md.BnXfAZay.lean.js"},{"revision":null,"url":"assets/core_useThrottledRefHistory_index.md.wiGZWEAo.js"},{"revision":null,"url":"assets/core_useThrottledRefHistory_index.md.wiGZWEAo.lean.js"},{"revision":null,"url":"assets/core_useTimeAgo_index.md.BBOR1lU-.js"},{"revision":null,"url":"assets/core_useTimeAgo_index.md.BBOR1lU-.lean.js"},{"revision":null,"url":"assets/core_useTimeAgoIntl_index.md.COXsMkKW.js"},{"revision":null,"url":"assets/core_useTimeAgoIntl_index.md.COXsMkKW.lean.js"},{"revision":null,"url":"assets/core_useTimeoutPoll_index.md.B6l5tGN_.js"},{"revision":null,"url":"assets/core_useTimeoutPoll_index.md.B6l5tGN_.lean.js"},{"revision":null,"url":"assets/core_useTimestamp_index.md.nnxS_boV.js"},{"revision":null,"url":"assets/core_useTimestamp_index.md.nnxS_boV.lean.js"},{"revision":null,"url":"assets/core_useTitle_index.md.0-DCl1C7.js"},{"revision":null,"url":"assets/core_useTitle_index.md.0-DCl1C7.lean.js"},{"revision":null,"url":"assets/core_useTransition_index.md.CIkqSAz8.js"},{"revision":null,"url":"assets/core_useTransition_index.md.CIkqSAz8.lean.js"},{"revision":null,"url":"assets/core_useUrlSearchParams_index.md.DBy1bIvR.js"},{"revision":null,"url":"assets/core_useUrlSearchParams_index.md.DBy1bIvR.lean.js"},{"revision":null,"url":"assets/core_useUserMedia_index.md.Dmx0Z6A4.js"},{"revision":null,"url":"assets/core_useUserMedia_index.md.Dmx0Z6A4.lean.js"},{"revision":null,"url":"assets/core_useVibrate_index.md.CXarxNg5.js"},{"revision":null,"url":"assets/core_useVibrate_index.md.CXarxNg5.lean.js"},{"revision":null,"url":"assets/core_useVirtualList_index.md.BeDrkdXg.js"},{"revision":null,"url":"assets/core_useVirtualList_index.md.BeDrkdXg.lean.js"},{"revision":null,"url":"assets/core_useVModel_index.md.o1pQCShk.js"},{"revision":null,"url":"assets/core_useVModel_index.md.o1pQCShk.lean.js"},{"revision":null,"url":"assets/core_useVModels_index.md.CjTxfGcG.js"},{"revision":null,"url":"assets/core_useVModels_index.md.CjTxfGcG.lean.js"},{"revision":null,"url":"assets/core_useWakeLock_index.md.59SjdvJB.js"},{"revision":null,"url":"assets/core_useWakeLock_index.md.59SjdvJB.lean.js"},{"revision":null,"url":"assets/core_useWebNotification_index.md.DXWpwBps.js"},{"revision":null,"url":"assets/core_useWebNotification_index.md.DXWpwBps.lean.js"},{"revision":null,"url":"assets/core_useWebSocket_index.md.CdD-ywWR.js"},{"revision":null,"url":"assets/core_useWebSocket_index.md.CdD-ywWR.lean.js"},{"revision":null,"url":"assets/core_useWebWorker_index.md.BGpyQ42P.js"},{"revision":null,"url":"assets/core_useWebWorker_index.md.BGpyQ42P.lean.js"},{"revision":null,"url":"assets/core_useWebWorkerFn_index.md.CZcW1v5c.js"},{"revision":null,"url":"assets/core_useWebWorkerFn_index.md.CZcW1v5c.lean.js"},{"revision":null,"url":"assets/core_useWindowFocus_index.md.CYdksxf6.js"},{"revision":null,"url":"assets/core_useWindowFocus_index.md.CYdksxf6.lean.js"},{"revision":null,"url":"assets/core_useWindowScroll_index.md.CzqNH07V.js"},{"revision":null,"url":"assets/core_useWindowScroll_index.md.CzqNH07V.lean.js"},{"revision":null,"url":"assets/core_useWindowSize_index.md.Cr8Up-Vw.js"},{"revision":null,"url":"assets/core_useWindowSize_index.md.Cr8Up-Vw.lean.js"},{"revision":null,"url":"assets/ecosystem.md.DmBeSD34.js"},{"revision":null,"url":"assets/ecosystem.md.DmBeSD34.lean.js"},{"revision":null,"url":"assets/electron_README.md.BuY0UMK3.js"},{"revision":null,"url":"assets/electron_README.md.BuY0UMK3.lean.js"},{"revision":null,"url":"assets/electron_useIpcRenderer_index.md.CWwnVm3a.js"},{"revision":null,"url":"assets/electron_useIpcRenderer_index.md.CWwnVm3a.lean.js"},{"revision":null,"url":"assets/electron_useIpcRendererInvoke_index.md.Bmh2tznD.js"},{"revision":null,"url":"assets/electron_useIpcRendererInvoke_index.md.Bmh2tznD.lean.js"},{"revision":null,"url":"assets/electron_useIpcRendererOn_index.md.cHEkW6wg.js"},{"revision":null,"url":"assets/electron_useIpcRendererOn_index.md.cHEkW6wg.lean.js"},{"revision":null,"url":"assets/electron_useZoomFactor_index.md.DG0UxNdZ.js"},{"revision":null,"url":"assets/electron_useZoomFactor_index.md.DG0UxNdZ.lean.js"},{"revision":null,"url":"assets/electron_useZoomLevel_index.md.DKuexFB_.js"},{"revision":null,"url":"assets/electron_useZoomLevel_index.md.DKuexFB_.lean.js"},{"revision":null,"url":"assets/export-size.md.DpIjauQK.js"},{"revision":null,"url":"assets/export-size.md.DpIjauQK.lean.js"},{"revision":null,"url":"assets/firebase_README.md.DBfCCLe8.js"},{"revision":null,"url":"assets/firebase_README.md.DBfCCLe8.lean.js"},{"revision":null,"url":"assets/firebase_useAuth_index.md.CNYdQKrP.js"},{"revision":null,"url":"assets/firebase_useAuth_index.md.CNYdQKrP.lean.js"},{"revision":null,"url":"assets/firebase_useFirestore_index.md.Bk1BC0Fo.js"},{"revision":null,"url":"assets/firebase_useFirestore_index.md.Bk1BC0Fo.lean.js"},{"revision":null,"url":"assets/firebase_useRTDB_index.md.bgmIFMjw.js"},{"revision":null,"url":"assets/firebase_useRTDB_index.md.bgmIFMjw.lean.js"},{"revision":null,"url":"assets/functions.md.CGpah3ui.js"},{"revision":null,"url":"assets/functions.md.CGpah3ui.lean.js"},{"revision":null,"url":"assets/guide_best-practice.md.CwOk4yX1.js"},{"revision":null,"url":"assets/guide_best-practice.md.CwOk4yX1.lean.js"},{"revision":null,"url":"assets/guide_components.md.B6JTbzb7.js"},{"revision":null,"url":"assets/guide_components.md.B6JTbzb7.lean.js"},{"revision":null,"url":"assets/guide_config.md.BQkqonMS.js"},{"revision":null,"url":"assets/guide_config.md.BQkqonMS.lean.js"},{"revision":null,"url":"assets/guide_index.md.OLC42GQt.js"},{"revision":null,"url":"assets/guide_index.md.OLC42GQt.lean.js"},{"revision":null,"url":"assets/guidelines.md.jmF-T7E_.js"},{"revision":null,"url":"assets/guidelines.md.jmF-T7E_.lean.js"},{"revision":null,"url":"assets/index.md.DUtI6oDP.js"},{"revision":null,"url":"assets/index.md.DUtI6oDP.lean.js"},{"revision":null,"url":"assets/integrations_README.md.CNPxdMbC.js"},{"revision":null,"url":"assets/integrations_README.md.CNPxdMbC.lean.js"},{"revision":null,"url":"assets/integrations_useAsyncValidator_index.md.aUNcpOWK.js"},{"revision":null,"url":"assets/integrations_useAsyncValidator_index.md.aUNcpOWK.lean.js"},{"revision":null,"url":"assets/integrations_useAxios_index.md.OBXwAb_e.js"},{"revision":null,"url":"assets/integrations_useAxios_index.md.OBXwAb_e.lean.js"},{"revision":null,"url":"assets/integrations_useChangeCase_index.md.FfThewc7.js"},{"revision":null,"url":"assets/integrations_useChangeCase_index.md.FfThewc7.lean.js"},{"revision":null,"url":"assets/integrations_useCookies_index.md.Z-JR8G2S.js"},{"revision":null,"url":"assets/integrations_useCookies_index.md.Z-JR8G2S.lean.js"},{"revision":null,"url":"assets/integrations_useDrauu_index.md.hdEe3n-G.js"},{"revision":null,"url":"assets/integrations_useDrauu_index.md.hdEe3n-G.lean.js"},{"revision":null,"url":"assets/integrations_useFocusTrap_index.md.28ZYF4lH.js"},{"revision":null,"url":"assets/integrations_useFocusTrap_index.md.28ZYF4lH.lean.js"},{"revision":null,"url":"assets/integrations_useFuse_index.md.DDgtcapa.js"},{"revision":null,"url":"assets/integrations_useFuse_index.md.DDgtcapa.lean.js"},{"revision":null,"url":"assets/integrations_useIDBKeyval_index.md.DlblK1Sc.js"},{"revision":null,"url":"assets/integrations_useIDBKeyval_index.md.DlblK1Sc.lean.js"},{"revision":null,"url":"assets/integrations_useJwt_index.md.BMVo7uDX.js"},{"revision":null,"url":"assets/integrations_useJwt_index.md.BMVo7uDX.lean.js"},{"revision":null,"url":"assets/integrations_useNProgress_index.md.DSTc65QY.js"},{"revision":null,"url":"assets/integrations_useNProgress_index.md.DSTc65QY.lean.js"},{"revision":null,"url":"assets/integrations_useQRCode_index.md.BQiWHS28.js"},{"revision":null,"url":"assets/integrations_useQRCode_index.md.BQiWHS28.lean.js"},{"revision":null,"url":"assets/integrations_useSortable_index.md.CYJU8hdk.js"},{"revision":null,"url":"assets/integrations_useSortable_index.md.CYJU8hdk.lean.js"},{"revision":null,"url":"assets/inter-italic-cyrillic-ext.r48I6akx.woff2"},{"revision":null,"url":"assets/inter-italic-cyrillic.By2_1cv3.woff2"},{"revision":null,"url":"assets/inter-italic-greek-ext.1u6EdAuj.woff2"},{"revision":null,"url":"assets/inter-italic-greek.DJ8dCoTZ.woff2"},{"revision":null,"url":"assets/inter-italic-latin-ext.CN1xVJS-.woff2"},{"revision":null,"url":"assets/inter-italic-latin.C2AdPX0b.woff2"},{"revision":null,"url":"assets/inter-italic-vietnamese.BSbpV94h.woff2"},{"revision":null,"url":"assets/inter-roman-cyrillic-ext.BBPuwvHQ.woff2"},{"revision":null,"url":"assets/inter-roman-cyrillic.C5lxZ8CY.woff2"},{"revision":null,"url":"assets/inter-roman-greek-ext.CqjqNYQ-.woff2"},{"revision":null,"url":"assets/inter-roman-greek.BBVDIX6e.woff2"},{"revision":null,"url":"assets/inter-roman-latin-ext.4ZJIpNVo.woff2"},{"revision":null,"url":"assets/inter-roman-latin.Di8DUHzh.woff2"},{"revision":null,"url":"assets/inter-roman-vietnamese.BjW4sHH5.woff2"},{"revision":null,"url":"assets/math_createGenericProjection_index.md.CbUryaRB.js"},{"revision":null,"url":"assets/math_createGenericProjection_index.md.CbUryaRB.lean.js"},{"revision":null,"url":"assets/math_createProjection_index.md.CYiEl-iF.js"},{"revision":null,"url":"assets/math_createProjection_index.md.CYiEl-iF.lean.js"},{"revision":null,"url":"assets/math_logicAnd_index.md.DImCK67d.js"},{"revision":null,"url":"assets/math_logicAnd_index.md.DImCK67d.lean.js"},{"revision":null,"url":"assets/math_logicNot_index.md.CAZYHC2o.js"},{"revision":null,"url":"assets/math_logicNot_index.md.CAZYHC2o.lean.js"},{"revision":null,"url":"assets/math_logicOr_index.md.kdCA_bFN.js"},{"revision":null,"url":"assets/math_logicOr_index.md.kdCA_bFN.lean.js"},{"revision":null,"url":"assets/math_README.md.BoSjYcAW.js"},{"revision":null,"url":"assets/math_README.md.BoSjYcAW.lean.js"},{"revision":null,"url":"assets/math_useAbs_index.md.BvhPQ6_W.js"},{"revision":null,"url":"assets/math_useAbs_index.md.BvhPQ6_W.lean.js"},{"revision":null,"url":"assets/math_useAverage_index.md.ChYJa8q9.js"},{"revision":null,"url":"assets/math_useAverage_index.md.ChYJa8q9.lean.js"},{"revision":null,"url":"assets/math_useCeil_index.md.B8KEnNvt.js"},{"revision":null,"url":"assets/math_useCeil_index.md.B8KEnNvt.lean.js"},{"revision":null,"url":"assets/math_useClamp_index.md.BplSiIJN.js"},{"revision":null,"url":"assets/math_useClamp_index.md.BplSiIJN.lean.js"},{"revision":null,"url":"assets/math_useFloor_index.md.B73KpRVJ.js"},{"revision":null,"url":"assets/math_useFloor_index.md.B73KpRVJ.lean.js"},{"revision":null,"url":"assets/math_useMath_index.md.BLJ6gpjY.js"},{"revision":null,"url":"assets/math_useMath_index.md.BLJ6gpjY.lean.js"},{"revision":null,"url":"assets/math_useMax_index.md.BiUbgkzq.js"},{"revision":null,"url":"assets/math_useMax_index.md.BiUbgkzq.lean.js"},{"revision":null,"url":"assets/math_useMin_index.md.DrHkwBr_.js"},{"revision":null,"url":"assets/math_useMin_index.md.DrHkwBr_.lean.js"},{"revision":null,"url":"assets/math_usePrecision_index.md.VFunRhr9.js"},{"revision":null,"url":"assets/math_usePrecision_index.md.VFunRhr9.lean.js"},{"revision":null,"url":"assets/math_useProjection_index.md.CJrBXhJ2.js"},{"revision":null,"url":"assets/math_useProjection_index.md.CJrBXhJ2.lean.js"},{"revision":null,"url":"assets/math_useRound_index.md.Ddwif6pn.js"},{"revision":null,"url":"assets/math_useRound_index.md.Ddwif6pn.lean.js"},{"revision":null,"url":"assets/math_useSum_index.md.CMY2_c3O.js"},{"revision":null,"url":"assets/math_useSum_index.md.CMY2_c3O.lean.js"},{"revision":null,"url":"assets/math_useTrunc_index.md.huV2gRFY.js"},{"revision":null,"url":"assets/math_useTrunc_index.md.huV2gRFY.lean.js"},{"revision":null,"url":"assets/nuxt_README.md.Dl83kEbr.js"},{"revision":null,"url":"assets/nuxt_README.md.Dl83kEbr.lean.js"},{"revision":null,"url":"assets/router_README.md.C7TQRv5w.js"},{"revision":null,"url":"assets/router_README.md.C7TQRv5w.lean.js"},{"revision":null,"url":"assets/router_useRouteHash_index.md.DMu3FbqF.js"},{"revision":null,"url":"assets/router_useRouteHash_index.md.DMu3FbqF.lean.js"},{"revision":null,"url":"assets/router_useRouteParams_index.md.Dx3WAwSd.js"},{"revision":null,"url":"assets/router_useRouteParams_index.md.Dx3WAwSd.lean.js"},{"revision":null,"url":"assets/router_useRouteQuery_index.md.DVQAxUj7.js"},{"revision":null,"url":"assets/router_useRouteQuery_index.md.DVQAxUj7.lean.js"},{"revision":null,"url":"assets/rxjs_from_index.md.CBclSNDQ.js"},{"revision":null,"url":"assets/rxjs_from_index.md.CBclSNDQ.lean.js"},{"revision":null,"url":"assets/rxjs_README.md.D2sx5YBW.js"},{"revision":null,"url":"assets/rxjs_README.md.D2sx5YBW.lean.js"},{"revision":null,"url":"assets/rxjs_toObserver_index.md.CFU2O8jW.js"},{"revision":null,"url":"assets/rxjs_toObserver_index.md.CFU2O8jW.lean.js"},{"revision":null,"url":"assets/rxjs_useExtractedObservable_index.md.CciFlI7B.js"},{"revision":null,"url":"assets/rxjs_useExtractedObservable_index.md.CciFlI7B.lean.js"},{"revision":null,"url":"assets/rxjs_useObservable_index.md.DM8ZaIGd.js"},{"revision":null,"url":"assets/rxjs_useObservable_index.md.DM8ZaIGd.lean.js"},{"revision":null,"url":"assets/rxjs_useSubject_index.md.DYSahLuz.js"},{"revision":null,"url":"assets/rxjs_useSubject_index.md.DYSahLuz.lean.js"},{"revision":null,"url":"assets/rxjs_useSubscription_index.md.CEAdULxx.js"},{"revision":null,"url":"assets/rxjs_useSubscription_index.md.CEAdULxx.lean.js"},{"revision":null,"url":"assets/rxjs_watchExtractedObservable_index.md.W_P4hmdW.js"},{"revision":null,"url":"assets/rxjs_watchExtractedObservable_index.md.W_P4hmdW.lean.js"},{"revision":null,"url":"assets/shared_computedEager_index.md.DcLyNNAr.js"},{"revision":null,"url":"assets/shared_computedEager_index.md.DcLyNNAr.lean.js"},{"revision":null,"url":"assets/shared_computedWithControl_index.md.7gwLVEdq.js"},{"revision":null,"url":"assets/shared_computedWithControl_index.md.7gwLVEdq.lean.js"},{"revision":null,"url":"assets/shared_createEventHook_index.md.C3VG7gmR.js"},{"revision":null,"url":"assets/shared_createEventHook_index.md.C3VG7gmR.lean.js"},{"revision":null,"url":"assets/shared_createGlobalState_index.md.Cie_4sOl.js"},{"revision":null,"url":"assets/shared_createGlobalState_index.md.Cie_4sOl.lean.js"},{"revision":null,"url":"assets/shared_createInjectionState_index.md.BOUJkOyO.js"},{"revision":null,"url":"assets/shared_createInjectionState_index.md.BOUJkOyO.lean.js"},{"revision":null,"url":"assets/shared_createRef_index.md.iTGiS7dr.js"},{"revision":null,"url":"assets/shared_createRef_index.md.iTGiS7dr.lean.js"},{"revision":null,"url":"assets/shared_createSharedComposable_index.md.urstpDDK.js"},{"revision":null,"url":"assets/shared_createSharedComposable_index.md.urstpDDK.lean.js"},{"revision":null,"url":"assets/shared_extendRef_index.md.DIHf-Idr.js"},{"revision":null,"url":"assets/shared_extendRef_index.md.DIHf-Idr.lean.js"},{"revision":null,"url":"assets/shared_get_index.md.BhyK3Npw.js"},{"revision":null,"url":"assets/shared_get_index.md.BhyK3Npw.lean.js"},{"revision":null,"url":"assets/shared_injectLocal_index.md.BOhHoe7h.js"},{"revision":null,"url":"assets/shared_injectLocal_index.md.BOhHoe7h.lean.js"},{"revision":null,"url":"assets/shared_isDefined_index.md.HHviDhGv.js"},{"revision":null,"url":"assets/shared_isDefined_index.md.HHviDhGv.lean.js"},{"revision":null,"url":"assets/shared_makeDestructurable_index.md.CZp8RKTL.js"},{"revision":null,"url":"assets/shared_makeDestructurable_index.md.CZp8RKTL.lean.js"},{"revision":null,"url":"assets/shared_provideLocal_index.md.CEEKzWWV.js"},{"revision":null,"url":"assets/shared_provideLocal_index.md.CEEKzWWV.lean.js"},{"revision":null,"url":"assets/shared_reactify_index.md.D3RB-ISh.js"},{"revision":null,"url":"assets/shared_reactify_index.md.D3RB-ISh.lean.js"},{"revision":null,"url":"assets/shared_reactifyObject_index.md.DeDX4KVQ.js"},{"revision":null,"url":"assets/shared_reactifyObject_index.md.DeDX4KVQ.lean.js"},{"revision":null,"url":"assets/shared_reactiveComputed_index.md.DljIKg8E.js"},{"revision":null,"url":"assets/shared_reactiveComputed_index.md.DljIKg8E.lean.js"},{"revision":null,"url":"assets/shared_reactiveOmit_index.md.BbhV3N8H.js"},{"revision":null,"url":"assets/shared_reactiveOmit_index.md.BbhV3N8H.lean.js"},{"revision":null,"url":"assets/shared_reactivePick_index.md.BfYHArLP.js"},{"revision":null,"url":"assets/shared_reactivePick_index.md.BfYHArLP.lean.js"},{"revision":null,"url":"assets/shared_refAutoReset_index.md.X_0fyh3y.js"},{"revision":null,"url":"assets/shared_refAutoReset_index.md.X_0fyh3y.lean.js"},{"revision":null,"url":"assets/shared_refDebounced_index.md.CvGupwpp.js"},{"revision":null,"url":"assets/shared_refDebounced_index.md.CvGupwpp.lean.js"},{"revision":null,"url":"assets/shared_refDefault_index.md.CKs3bKfd.js"},{"revision":null,"url":"assets/shared_refDefault_index.md.CKs3bKfd.lean.js"},{"revision":null,"url":"assets/shared_refManualReset_index.md.BRn41nT-.js"},{"revision":null,"url":"assets/shared_refManualReset_index.md.BRn41nT-.lean.js"},{"revision":null,"url":"assets/shared_refThrottled_index.md.CE09e7al.js"},{"revision":null,"url":"assets/shared_refThrottled_index.md.CE09e7al.lean.js"},{"revision":null,"url":"assets/shared_refWithControl_index.md.BCFg_Z6v.js"},{"revision":null,"url":"assets/shared_refWithControl_index.md.BCFg_Z6v.lean.js"},{"revision":null,"url":"assets/shared_set_index.md.CYmoTfb0.js"},{"revision":null,"url":"assets/shared_set_index.md.CYmoTfb0.lean.js"},{"revision":null,"url":"assets/shared_syncRef_index.md.CeNkUwbc.js"},{"revision":null,"url":"assets/shared_syncRef_index.md.CeNkUwbc.lean.js"},{"revision":null,"url":"assets/shared_syncRefs_index.md.CvvKwDhB.js"},{"revision":null,"url":"assets/shared_syncRefs_index.md.CvvKwDhB.lean.js"},{"revision":null,"url":"assets/shared_toReactive_index.md._72TLzq8.js"},{"revision":null,"url":"assets/shared_toReactive_index.md._72TLzq8.lean.js"},{"revision":null,"url":"assets/shared_toRef_index.md.DfEt_m6w.js"},{"revision":null,"url":"assets/shared_toRef_index.md.DfEt_m6w.lean.js"},{"revision":null,"url":"assets/shared_toRefs_index.md.HxaId9Ex.js"},{"revision":null,"url":"assets/shared_toRefs_index.md.HxaId9Ex.lean.js"},{"revision":null,"url":"assets/shared_tryOnBeforeMount_index.md.Dqr0rrZ6.js"},{"revision":null,"url":"assets/shared_tryOnBeforeMount_index.md.Dqr0rrZ6.lean.js"},{"revision":null,"url":"assets/shared_tryOnBeforeUnmount_index.md.KdQ8qRLi.js"},{"revision":null,"url":"assets/shared_tryOnBeforeUnmount_index.md.KdQ8qRLi.lean.js"},{"revision":null,"url":"assets/shared_tryOnMounted_index.md.CghOIOFa.js"},{"revision":null,"url":"assets/shared_tryOnMounted_index.md.CghOIOFa.lean.js"},{"revision":null,"url":"assets/shared_tryOnScopeDispose_index.md.DOaxgYh2.js"},{"revision":null,"url":"assets/shared_tryOnScopeDispose_index.md.DOaxgYh2.lean.js"},{"revision":null,"url":"assets/shared_tryOnUnmounted_index.md.CIsFpvrA.js"},{"revision":null,"url":"assets/shared_tryOnUnmounted_index.md.CIsFpvrA.lean.js"},{"revision":null,"url":"assets/shared_until_index.md.BarDw5TY.js"},{"revision":null,"url":"assets/shared_until_index.md.BarDw5TY.lean.js"},{"revision":null,"url":"assets/shared_useArrayDifference_index.md.Crh5vI5Z.js"},{"revision":null,"url":"assets/shared_useArrayDifference_index.md.Crh5vI5Z.lean.js"},{"revision":null,"url":"assets/shared_useArrayEvery_index.md.DpEGcAa_.js"},{"revision":null,"url":"assets/shared_useArrayEvery_index.md.DpEGcAa_.lean.js"},{"revision":null,"url":"assets/shared_useArrayFilter_index.md.DyjGD6xp.js"},{"revision":null,"url":"assets/shared_useArrayFilter_index.md.DyjGD6xp.lean.js"},{"revision":null,"url":"assets/shared_useArrayFind_index.md.DM0OiIzP.js"},{"revision":null,"url":"assets/shared_useArrayFind_index.md.DM0OiIzP.lean.js"},{"revision":null,"url":"assets/shared_useArrayFindIndex_index.md.pEJiFPXn.js"},{"revision":null,"url":"assets/shared_useArrayFindIndex_index.md.pEJiFPXn.lean.js"},{"revision":null,"url":"assets/shared_useArrayFindLast_index.md.BQDpRju7.js"},{"revision":null,"url":"assets/shared_useArrayFindLast_index.md.BQDpRju7.lean.js"},{"revision":null,"url":"assets/shared_useArrayIncludes_index.md.CLIgCJr0.js"},{"revision":null,"url":"assets/shared_useArrayIncludes_index.md.CLIgCJr0.lean.js"},{"revision":null,"url":"assets/shared_useArrayJoin_index.md.orKbLiHP.js"},{"revision":null,"url":"assets/shared_useArrayJoin_index.md.orKbLiHP.lean.js"},{"revision":null,"url":"assets/shared_useArrayMap_index.md.EZNoNPVU.js"},{"revision":null,"url":"assets/shared_useArrayMap_index.md.EZNoNPVU.lean.js"},{"revision":null,"url":"assets/shared_useArrayReduce_index.md.DKterfIx.js"},{"revision":null,"url":"assets/shared_useArrayReduce_index.md.DKterfIx.lean.js"},{"revision":null,"url":"assets/shared_useArraySome_index.md.0Azhhcwr.js"},{"revision":null,"url":"assets/shared_useArraySome_index.md.0Azhhcwr.lean.js"},{"revision":null,"url":"assets/shared_useArrayUnique_index.md.CWY1mOWL.js"},{"revision":null,"url":"assets/shared_useArrayUnique_index.md.CWY1mOWL.lean.js"},{"revision":null,"url":"assets/shared_useCounter_index.md.Cq8rfgXO.js"},{"revision":null,"url":"assets/shared_useCounter_index.md.Cq8rfgXO.lean.js"},{"revision":null,"url":"assets/shared_useDateFormat_index.md.D80MYJUB.js"},{"revision":null,"url":"assets/shared_useDateFormat_index.md.D80MYJUB.lean.js"},{"revision":null,"url":"assets/shared_useDebounceFn_index.md.DJLq1vsF.js"},{"revision":null,"url":"assets/shared_useDebounceFn_index.md.DJLq1vsF.lean.js"},{"revision":null,"url":"assets/shared_useInterval_index.md.Cu8-Pxml.js"},{"revision":null,"url":"assets/shared_useInterval_index.md.Cu8-Pxml.lean.js"},{"revision":null,"url":"assets/shared_useIntervalFn_index.md.CBOPqKu8.js"},{"revision":null,"url":"assets/shared_useIntervalFn_index.md.CBOPqKu8.lean.js"},{"revision":null,"url":"assets/shared_useLastChanged_index.md._D37VVXN.js"},{"revision":null,"url":"assets/shared_useLastChanged_index.md._D37VVXN.lean.js"},{"revision":null,"url":"assets/shared_useThrottleFn_index.md.DFhRYSWI.js"},{"revision":null,"url":"assets/shared_useThrottleFn_index.md.DFhRYSWI.lean.js"},{"revision":null,"url":"assets/shared_useTimeout_index.md.BTefn5zy.js"},{"revision":null,"url":"assets/shared_useTimeout_index.md.BTefn5zy.lean.js"},{"revision":null,"url":"assets/shared_useTimeoutFn_index.md.a7gq2HAk.js"},{"revision":null,"url":"assets/shared_useTimeoutFn_index.md.a7gq2HAk.lean.js"},{"revision":null,"url":"assets/shared_useToggle_index.md.Du6_bbdf.js"},{"revision":null,"url":"assets/shared_useToggle_index.md.Du6_bbdf.lean.js"},{"revision":null,"url":"assets/shared_useToNumber_index.md.BrWOvtlS.js"},{"revision":null,"url":"assets/shared_useToNumber_index.md.BrWOvtlS.lean.js"},{"revision":null,"url":"assets/shared_useToString_index.md.C8vTFISf.js"},{"revision":null,"url":"assets/shared_useToString_index.md.C8vTFISf.lean.js"},{"revision":null,"url":"assets/shared_watchArray_index.md.FtVDzZ7R.js"},{"revision":null,"url":"assets/shared_watchArray_index.md.FtVDzZ7R.lean.js"},{"revision":null,"url":"assets/shared_watchAtMost_index.md.CcIpMTGo.js"},{"revision":null,"url":"assets/shared_watchAtMost_index.md.CcIpMTGo.lean.js"},{"revision":null,"url":"assets/shared_watchDebounced_index.md.BRq2mp2G.js"},{"revision":null,"url":"assets/shared_watchDebounced_index.md.BRq2mp2G.lean.js"},{"revision":null,"url":"assets/shared_watchDeep_index.md.DzntAnKN.js"},{"revision":null,"url":"assets/shared_watchDeep_index.md.DzntAnKN.lean.js"},{"revision":null,"url":"assets/shared_watchIgnorable_index.md.yL6uVvQP.js"},{"revision":null,"url":"assets/shared_watchIgnorable_index.md.yL6uVvQP.lean.js"},{"revision":null,"url":"assets/shared_watchImmediate_index.md.7OnJHW50.js"},{"revision":null,"url":"assets/shared_watchImmediate_index.md.7OnJHW50.lean.js"},{"revision":null,"url":"assets/shared_watchOnce_index.md.CqAJ4G5o.js"},{"revision":null,"url":"assets/shared_watchOnce_index.md.CqAJ4G5o.lean.js"},{"revision":null,"url":"assets/shared_watchPausable_index.md.DetnbmWb.js"},{"revision":null,"url":"assets/shared_watchPausable_index.md.DetnbmWb.lean.js"},{"revision":null,"url":"assets/shared_watchThrottled_index.md.lObqb2f-.js"},{"revision":null,"url":"assets/shared_watchThrottled_index.md.lObqb2f-.lean.js"},{"revision":null,"url":"assets/shared_watchTriggerable_index.md.Du22iIHf.js"},{"revision":null,"url":"assets/shared_watchTriggerable_index.md.Du22iIHf.lean.js"},{"revision":null,"url":"assets/shared_watchWithFilter_index.md.BvE19VRT.js"},{"revision":null,"url":"assets/shared_watchWithFilter_index.md.BvE19VRT.lean.js"},{"revision":null,"url":"assets/shared_whenever_index.md.DFHZDiOa.js"},{"revision":null,"url":"assets/shared_whenever_index.md.DFHZDiOa.lean.js"},{"revision":null,"url":"assets/style.BSgS37IS.css"},{"revision":null,"url":"assets/team.md.BxD_0HXd.js"},{"revision":null,"url":"assets/team.md.BxD_0HXd.lean.js"},{"revision":null,"url":"assets/why-no-translations.md.BLJK_fJ2.js"},{"revision":null,"url":"assets/why-no-translations.md.BLJK_fJ2.lean.js"},{"revision":"683c1aeac94d03c11965dd72904ac6be","url":"badge-function-count.svg"},{"revision":"48fd8b40e2fe2c5f07eeb99d41a49b82","url":"components/README.html"},{"revision":"bed8ec0df9981a1fe429b73681a22815","url":"contributing.html"},{"revision":"16fd2032ee9b0b81c832711da7b25225","url":"core/_template/index.html"},{"revision":"9e79079eb5bb8dcaf7c55ae9e899ff55","url":"core/computedAsync/index.html"},{"revision":"2e54b44d48a517b73164653427d96336","url":"core/computedInject/index.html"},{"revision":"d98c6aedec3d1c5247726e8ef1c656db","url":"core/createReusableTemplate/index.html"},{"revision":"40fd4a48595974b52eb6da6633bca472","url":"core/createTemplatePromise/index.html"},{"revision":"c25dbfe23305fb48df69008e298b7549","url":"core/createUnrefFn/index.html"},{"revision":"1a7ff6b06f503ecb5fed6150e536e26a","url":"core/onClickOutside/index.html"},{"revision":"203a813f0425f61607c64c69d9a4ab51","url":"core/onElementRemoval/index.html"},{"revision":"afefdc6fd4a1f4b7293305ff5d78d78a","url":"core/onKeyStroke/index.html"},{"revision":"bf4df441787bee3c285a8c2a155c6d50","url":"core/onLongPress/index.html"},{"revision":"3e5bb79aa3ba82e71b6be103670a9d51","url":"core/onStartTyping/index.html"},{"revision":"0b6dde37126845498643c29c7cef48ca","url":"core/README.html"},{"revision":"1fccd8d6007f5543a847f897c8d5ef32","url":"core/templateRef/index.html"},{"revision":"5fa4f9f1f2efa64ddf059aac665b57bb","url":"core/unrefElement/index.html"},{"revision":"991ba37bba9150b8ae6611a412e84ff6","url":"core/useActiveElement/index.html"},{"revision":"3f6371d090ef86811cc2d8c3d8c512f2","url":"core/useAnimate/index.html"},{"revision":"08b5a3b68d47280a1bfc75af2248e124","url":"core/useAsyncQueue/index.html"},{"revision":"d4f7f9761bbb53a309304988ab4a0b93","url":"core/useAsyncState/index.html"},{"revision":"eafe433e5487e3d4b586c5b2246c8b6c","url":"core/useBase64/index.html"},{"revision":"d2eb0799ad35d35de5e7f55cb58a0139","url":"core/useBattery/index.html"},{"revision":"c0751767f7a88a47eb151723ab8ac281","url":"core/useBluetooth/index.html"},{"revision":"d504d10e0facc4f0896272dfbcecd62e","url":"core/useBreakpoints/index.html"},{"revision":"bfbb1fd80b31f67663e367b6e90c078c","url":"core/useBroadcastChannel/index.html"},{"revision":"e09adfa23278e0bbb1fdbb7759167ba8","url":"core/useBrowserLocation/index.html"},{"revision":"4c64a3c375f4431835cd77e5c58f6ad0","url":"core/useCached/index.html"},{"revision":"86f4a3ae65c5a6055886db3b28b8984a","url":"core/useClipboard/index.html"},{"revision":"bad38561f064ff986709f35868d718ef","url":"core/useClipboardItems/index.html"},{"revision":"6c83be95977f26a0f382e357aa6c3136","url":"core/useCloned/index.html"},{"revision":"89fe3ca19526e95620b64f2b83762581","url":"core/useColorMode/index.html"},{"revision":"3be31070aeddd23d2e5e596f0005e80b","url":"core/useConfirmDialog/index.html"},{"revision":"ddf1bf96d97c5dc5d440199b5fda6494","url":"core/useCountdown/index.html"},{"revision":"0ee9f3011bb390d76158563ee6a1c8b9","url":"core/useCssVar/index.html"},{"revision":"277a7480323f0f099def2307074f2854","url":"core/useCurrentElement/index.html"},{"revision":"19ca74f9a912a10c12bd1c7ba8b3f804","url":"core/useCycleList/index.html"},{"revision":"65a5d537f0428cea9720e9899b5d5988","url":"core/useDark/index.html"},{"revision":"dd56ffbf361e78248368e03238982668","url":"core/useDebouncedRefHistory/index.html"},{"revision":"d60a77303864a7f237cbb0de6336c1d3","url":"core/useDeviceMotion/index.html"},{"revision":"8b9c04f7c328d8513afafbd6f4d81a38","url":"core/useDeviceOrientation/index.html"},{"revision":"e0eef002426429ab296cc89cfbadd0af","url":"core/useDevicePixelRatio/index.html"},{"revision":"b7525a9e939b7d8ab95fe15e854b769e","url":"core/useDevicesList/index.html"},{"revision":"359931d954bfdb76559589cbf5e80e13","url":"core/useDisplayMedia/index.html"},{"revision":"02ccf551b83ec94b652be54c65a1a011","url":"core/useDocumentVisibility/index.html"},{"revision":"16c9e811f36290c6aa06cd3622e699a5","url":"core/useDraggable/index.html"},{"revision":"089e49422e97dde6182c0a8728066b2a","url":"core/useDropZone/index.html"},{"revision":"a748e577f94c2de617c5825393d9fb94","url":"core/useElementBounding/index.html"},{"revision":"4cc7758200f776486ce6a3b98a7da1df","url":"core/useElementByPoint/index.html"},{"revision":"09d92e8af4e70b8edd798f5ea0950915","url":"core/useElementHover/index.html"},{"revision":"12419af88be3942560772da3cecc0f96","url":"core/useElementSize/index.html"},{"revision":"fcd4916efb344649782afa5bc5e3ea25","url":"core/useElementVisibility/index.html"},{"revision":"1daa44249fede939b33da24773eb7573","url":"core/useEventBus/index.html"},{"revision":"e354601ad888befe1aa3e5f478451b7c","url":"core/useEventListener/index.html"},{"revision":"3129621acceeade0bebd1fcfc091fb8a","url":"core/useEventSource/index.html"},{"revision":"5ada49d381a834a01f67f2c73b51e516","url":"core/useEyeDropper/index.html"},{"revision":"c67e000fd7a99c28f72500f9c89112f9","url":"core/useFavicon/index.html"},{"revision":"099ad866f44af3ddc693cafb40811a75","url":"core/useFetch/index.html"},{"revision":"3c149fedcb60c4e843e9ac023cce2698","url":"core/useFileDialog/index.html"},{"revision":"e6b214d44c91675b71b216449e513f7c","url":"core/useFileSystemAccess/index.html"},{"revision":"5b0ca13d1c04598d6607afe50078e00b","url":"core/useFocus/index.html"},{"revision":"bd24b2ce82d4263b2ee04dda41b8a63c","url":"core/useFocusWithin/index.html"},{"revision":"a3ee1cb58ebb4e72a2a38650bdf4a021","url":"core/useFps/index.html"},{"revision":"b564cc1822422318c89757880610d374","url":"core/useFullscreen/index.html"},{"revision":"69d571123579b124faf670a5948ee420","url":"core/useGamepad/index.html"},{"revision":"52b415006926859c3ea5f8372dfe4dbd","url":"core/useGeolocation/index.html"},{"revision":"4a0db8550c8ca00ad19494266db7149f","url":"core/useIdle/index.html"},{"revision":"bffec511f7dfde4c4f94f3d469af0f89","url":"core/useImage/index.html"},{"revision":"1fa47e3afdd41d8a1724ef8a2b41360c","url":"core/useInfiniteScroll/index.html"},{"revision":"ee235fd6e1aeb313152d2a3f9df91441","url":"core/useIntersectionObserver/index.html"},{"revision":"05dbbe85b29713dd96ec738fd69f2ef2","url":"core/useKeyModifier/index.html"},{"revision":"8f72a798a286826144fee81048af9eb6","url":"core/useLocalStorage/index.html"},{"revision":"2ac18a96daa8cb3922fb605a4f7784ae","url":"core/useMagicKeys/index.html"},{"revision":"82d8940b42dda002b0ef4683e1e440ef","url":"core/useManualRefHistory/index.html"},{"revision":"fa0efa50c298044c377ef191af303039","url":"core/useMediaControls/index.html"},{"revision":"8f61b69b970656e5c5489a1d6ab59110","url":"core/useMediaQuery/index.html"},{"revision":"9edf37d39ae6c701400af6617c7122cf","url":"core/useMemoize/index.html"},{"revision":"7838115c2f54115175b730aaad126861","url":"core/useMemory/index.html"},{"revision":"263a9b28d01e4659bcb42f01dfc09325","url":"core/useMounted/index.html"},{"revision":"38bcfe59b8e0019762dca6d766c7cbd1","url":"core/useMouse/index.html"},{"revision":"f0b88f72316340ad72cab476dca759cb","url":"core/useMouseInElement/index.html"},{"revision":"614b3b8c7fbf2cba912d4a657325b8f8","url":"core/useMousePressed/index.html"},{"revision":"962e5f3f63303ddbf7b74476ee8b3256","url":"core/useMutationObserver/index.html"},{"revision":"e5740776018d32916645b84df8f37c67","url":"core/useNavigatorLanguage/index.html"},{"revision":"319ef016e8def44547e852af09ad23bc","url":"core/useNetwork/index.html"},{"revision":"f8da19d26f0b2df5e1dd4ec0f56a9a55","url":"core/useNow/index.html"},{"revision":"a2d658ab9fd6d4a1ec28a686379f5e01","url":"core/useObjectUrl/index.html"},{"revision":"099b50d9617958c6ff3ce9625ffad048","url":"core/useOffsetPagination/index.html"},{"revision":"5c957e07eeb840b25e278835d3c0a337","url":"core/useOnline/index.html"},{"revision":"9d5e53281aca3e9a4fa97ab706b5e468","url":"core/usePageLeave/index.html"},{"revision":"0aea6f29eba76f22ef100732859e8a8e","url":"core/useParallax/index.html"},{"revision":"e223e052c73c1bf6b8be7ade14cf7c8b","url":"core/useParentElement/index.html"},{"revision":"4c68d955b88210fe519de34ff4d03856","url":"core/usePerformanceObserver/index.html"},{"revision":"567520217cfa2fe95d2a7fbee95c2975","url":"core/usePermission/index.html"},{"revision":"280466a19b15d31e2d476c686b0e9a22","url":"core/usePointer/index.html"},{"revision":"1f47af53e8de75fc11ce2c13f58ff1ab","url":"core/usePointerLock/index.html"},{"revision":"2c99e6dab553a69a9e4466d538bf685d","url":"core/usePointerSwipe/index.html"},{"revision":"ddae78f78bb5df1735f6a22dd95c5ac9","url":"core/usePreferredColorScheme/index.html"},{"revision":"e7ac23738136eb225b818f162606b89e","url":"core/usePreferredContrast/index.html"},{"revision":"7fb34ce96cddc35ef5ae8df5823c5533","url":"core/usePreferredDark/index.html"},{"revision":"12e1f6fe6853e752a061b19f89997870","url":"core/usePreferredLanguages/index.html"},{"revision":"663e27b92dbc18a45c8a21c02d5f3cb7","url":"core/usePreferredReducedMotion/index.html"},{"revision":"dba8f7792136a0bd946c0ddda08075f8","url":"core/usePreferredReducedTransparency/index.html"},{"revision":"48b96f62e99b433d6acd23874c50511f","url":"core/usePrevious/index.html"},{"revision":"e01c5b1786bb32a23aa36d2bed7a848a","url":"core/useRafFn/index.html"},{"revision":"012d25e6ce0f273f9509708414fff262","url":"core/useRefHistory/index.html"},{"revision":"f103df88cac65488088304df43d03bba","url":"core/useResizeObserver/index.html"},{"revision":"a1f9ea42b4e0aede4a0b41e5bf5b42c4","url":"core/useScreenOrientation/index.html"},{"revision":"4664abf298ee6c97f746a3fa8d460c84","url":"core/useScreenSafeArea/index.html"},{"revision":"74185bca433134bf21d445980eb776b0","url":"core/useScriptTag/index.html"},{"revision":"7e8438a03a99d1bfb09bb3e815c1a7e5","url":"core/useScroll/index.html"},{"revision":"ff49a96dd53f93d3ad9ed47a2958d526","url":"core/useScrollLock/index.html"},{"revision":"5e3cca96a2b5df3cf8ad6292378b6b30","url":"core/useSessionStorage/index.html"},{"revision":"f5b1181cb97b9bffd71e0f31c4151ee3","url":"core/useShare/index.html"},{"revision":"1af48eead94b06f022615f68e97076e2","url":"core/useSorted/index.html"},{"revision":"ce08bc58b5ff7c8a1798db0fe5546a43","url":"core/useSpeechRecognition/index.html"},{"revision":"7514c7b2516dd1e54d8761c266bfb0be","url":"core/useSpeechSynthesis/index.html"},{"revision":"bfe0bbc5a5fb4f7cc44536ac7631fd6a","url":"core/useSSRWidth/index.html"},{"revision":"edd840d47c305ddab9e5901086edd5c1","url":"core/useStepper/index.html"},{"revision":"092bd335abbaef40dc503ecbe221bf58","url":"core/useStorage/index.html"},{"revision":"62dd4dfcdff2cc608c8c7cde83b6c1b9","url":"core/useStorageAsync/index.html"},{"revision":"279a0d5a803c7f184c546c2da5b38fe3","url":"core/useStyleTag/index.html"},{"revision":"e139efbd511bf87b303dd0e0023ee0af","url":"core/useSupported/index.html"},{"revision":"5f87c06c5cdb1de6f288138f749f42ea","url":"core/useSwipe/index.html"},{"revision":"b78fbec4bbed2e702b7d5e23958a0cbe","url":"core/useTemplateRefsList/index.html"},{"revision":"316f3421da2dbe26aae378b41d1b4ed8","url":"core/useTextareaAutosize/index.html"},{"revision":"608f5955bed2615959272e64461e71c0","url":"core/useTextDirection/index.html"},{"revision":"645396cf88f6487875b1504635114ae3","url":"core/useTextSelection/index.html"},{"revision":"2258457b4c13987eeaef31526061d3c4","url":"core/useThrottledRefHistory/index.html"},{"revision":"dbcc46e201b55eae250034a336d7ad14","url":"core/useTimeAgo/index.html"},{"revision":"3b55c03f45f3c718544d48cfff78a68b","url":"core/useTimeAgoIntl/index.html"},{"revision":"d13141f394c0feda3c8db11a13551902","url":"core/useTimeoutPoll/index.html"},{"revision":"224cfb532caa737dbb629d06c108db91","url":"core/useTimestamp/index.html"},{"revision":"9555fac07ff19b60ba5573ee4c2b2572","url":"core/useTitle/index.html"},{"revision":"c26dc5c12b5d854c5a6187ae991d6587","url":"core/useTransition/index.html"},{"revision":"f4803a144f738f2a52a4e83da918051a","url":"core/useUrlSearchParams/index.html"},{"revision":"e9d6e08da38726199cfce2bfe4f3c7c0","url":"core/useUserMedia/index.html"},{"revision":"a83e63439e41256f5eb44ead3dfa9a9b","url":"core/useVibrate/index.html"},{"revision":"24480a100f6fe1d07fa5a39933fbbb7a","url":"core/useVirtualList/index.html"},{"revision":"68e4578c95e3de8356f659aad245ed12","url":"core/useVModel/index.html"},{"revision":"ecc3cdb51e018cbe236cc0989c9df6f4","url":"core/useVModels/index.html"},{"revision":"dd8b351251cb14eddaf28f7389f78f51","url":"core/useWakeLock/index.html"},{"revision":"fa2767148bb8c468bc7728967efc1457","url":"core/useWebNotification/index.html"},{"revision":"a27aa05d81eb76031cdbe4fe3476c3b4","url":"core/useWebSocket/index.html"},{"revision":"fef8c4280d6a2919d54b65b1d39dfe10","url":"core/useWebWorker/index.html"},{"revision":"065d6eeab20f05d5bbeffcb3c2cb851b","url":"core/useWebWorkerFn/index.html"},{"revision":"d6c5e3ca18c682646457a5d3b508f365","url":"core/useWindowFocus/index.html"},{"revision":"db4df515469dd0060b1f383cd342cad3","url":"core/useWindowScroll/index.html"},{"revision":"55637c42d1dee7ff73464c0ca810ae5e","url":"core/useWindowSize/index.html"},{"revision":"3b28c64655504fc5df16961a3e6aea32","url":"ecosystem.html"},{"revision":"6ee0209ca0f9053f46c36a1025c72cae","url":"electron/README.html"},{"revision":"f7fefe68c5375231d2cca54a0ab576a3","url":"electron/useIpcRenderer/index.html"},{"revision":"7a4ce1f5f0f671bb0d35c537ce14c9ac","url":"electron/useIpcRendererInvoke/index.html"},{"revision":"e150532f4fa1021cb6058032fe642a82","url":"electron/useIpcRendererOn/index.html"},{"revision":"4ec83b38d54088c338ca0972bc987582","url":"electron/useZoomFactor/index.html"},{"revision":"550443b78ef19cd732c89b8267996daf","url":"electron/useZoomLevel/index.html"},{"revision":"6871d1c09059a9617a66c193e3c7a693","url":"export-size.html"},{"revision":"985261a9cd1ce4b1fdea403faac1e119","url":"favicon-16x16.png"},{"revision":"8556a0b6568697f1c8d76df245d676b9","url":"favicon-32x32.png"},{"revision":"fba46f9c76ff8cfb8c7e88710cab4892","url":"favicon.ico"},{"revision":"0f8c1cea3c233be4fb6ddfe3dd8f919b","url":"favicon.svg"},{"revision":"5b273127b0f992c054b6ca98481f1aef","url":"firebase/README.html"},{"revision":"355f5637ca46b386ce55b19261ee74a9","url":"firebase/useAuth/index.html"},{"revision":"a3a6ebf4c109d14014cabf75a6dc5408","url":"firebase/useFirestore/index.html"},{"revision":"ecf8dc78b2a2fc8067ff053517f4bc36","url":"firebase/useRTDB/index.html"},{"revision":"eeccff70623b935520bbb78f9955176b","url":"functions.html"},{"revision":"37974990fb21de2ccb36e2dc04f1b583","url":"guide/best-practice.html"},{"revision":"76a2dd1fe50e8c521ede7bcf355f1f04","url":"guide/components.html"},{"revision":"b017ad349565b5bdade34159e568c09d","url":"guide/config.html"},{"revision":"98249742c4a3efdf54c8333e889a9b85","url":"guide/index.html"},{"revision":"2aea484db4b6ed013fc683099a695352","url":"guidelines.html"},{"revision":"76bc00554a1fdda5583d1a3c7fbefdce","url":"index.html"},{"revision":"738709c152838a669a2fd8865a6ae580","url":"integrations/README.html"},{"revision":"5075cf285b8db41e555441f621638f04","url":"integrations/useAsyncValidator/index.html"},{"revision":"1f20376df1fb4c47f0c7c7e79eb24fd3","url":"integrations/useAxios/index.html"},{"revision":"12164a62c27a22c8feb2b8abb5e444f9","url":"integrations/useChangeCase/index.html"},{"revision":"0175963bbd8e8ac84ce3b187d15314db","url":"integrations/useCookies/index.html"},{"revision":"d89048c95d4a7090736e1dbcfd18b3dc","url":"integrations/useDrauu/index.html"},{"revision":"e3bd3da3668eaf72441735bba4d16220","url":"integrations/useFocusTrap/index.html"},{"revision":"6e44a89f948529c13c1fa2f0e8e16df9","url":"integrations/useFuse/index.html"},{"revision":"20a45cb3d57cb6f11c9d95b474c5fcb4","url":"integrations/useIDBKeyval/index.html"},{"revision":"3e7c5e24cd2a8df1c79c429f3f5791e8","url":"integrations/useJwt/index.html"},{"revision":"194091696cd87aaf3a2520acacb3494a","url":"integrations/useNProgress/index.html"},{"revision":"d182e959e24d89a073125cc527c9c96f","url":"integrations/useQRCode/index.html"},{"revision":"57b1a1da70bb5f04ff31806fd79074eb","url":"integrations/useSortable/index.html"},{"revision":"593a7e67c051b2ea0b109724fe2904c7","url":"logo-horizontal-dark.png"},{"revision":"9b3d7c4f6167d5ba8336961b9ed9f1cf","url":"logo-horizontal.png"},{"revision":"9816609c9d426f02bf6e87689108bcc2","url":"logo-vertical-dark.png"},{"revision":"ca8a4a4f2f6c8da2b3c8dc91c588f01c","url":"logo-vertical.png"},{"revision":"795dd8766cdee862b1f8b2a1b861ac89","url":"maskable-icon.png"},{"revision":"922599886c45fb46323e29264f1fe717","url":"math/createGenericProjection/index.html"},{"revision":"0362bf63c2d1183a1e4dfbf914c33437","url":"math/createProjection/index.html"},{"revision":"18eb801f5d828026505881539539a414","url":"math/logicAnd/index.html"},{"revision":"5906e6f9f2a461cb70f384dd122ab513","url":"math/logicNot/index.html"},{"revision":"d08c736862183d5d890d389e69f2d73c","url":"math/logicOr/index.html"},{"revision":"1f01ce0525ca1aa95266d7942d8d71c5","url":"math/README.html"},{"revision":"1eaa5a967097ce46ec8a7d50bc228b6b","url":"math/useAbs/index.html"},{"revision":"879f4c83b1ed0b7bc187262c1170c784","url":"math/useAverage/index.html"},{"revision":"c4e0e75aa2a21f74e2a9025ad8148688","url":"math/useCeil/index.html"},{"revision":"7cd4d9a3233d942cb7320ebe5d0d5541","url":"math/useClamp/index.html"},{"revision":"017fb4e8ad7f71679a6303c991c73284","url":"math/useFloor/index.html"},{"revision":"fa94854eee2c927da7010888f81ea666","url":"math/useMath/index.html"},{"revision":"b7d2abe17799e4419b8820efc25fae12","url":"math/useMax/index.html"},{"revision":"13479e16cbd21c68b251965032dc5a3c","url":"math/useMin/index.html"},{"revision":"9edc125f88804c8b0de4e0b131590fbe","url":"math/usePrecision/index.html"},{"revision":"81d05d7db911a35fb79f60bad2f97999","url":"math/useProjection/index.html"},{"revision":"5c692dd75f8fc0e28da062b3d25f6cd7","url":"math/useRound/index.html"},{"revision":"ef9e13fb50f1ecaec955e1f19d194076","url":"math/useSum/index.html"},{"revision":"1cf7f28cc1c16ab8037dada0f506058f","url":"math/useTrunc/index.html"},{"revision":"33af3b5f156956e8772b0acaace1452f","url":"netlify.svg"},{"revision":"85a50fd9a9985e31ebd59f8feaacac7d","url":"nuxt/README.html"},{"revision":"c0048fd2f2c0fc2668f411b5061a9864","url":"og.png"},{"revision":"3d946139dd7335cd95bad54f54fb5e3e","url":"pwa-192x192.png"},{"revision":"044d2455c529e3d1872d7c2dcc0835cf","url":"pwa-512x512.png"},{"revision":"e9f21b945a4d1b3ce239cefd5a579bf3","url":"pwa-64x64.png"},{"revision":"49d41197c6f48a204d6e25de58e2ead3","url":"router/README.html"},{"revision":"a133311d839478e105697e78a7a3af65","url":"router/useRouteHash/index.html"},{"revision":"6829cb67da4a354d1571b3f26e93ddfa","url":"router/useRouteParams/index.html"},{"revision":"ad38c5bae23b2490439cd51a29a7229f","url":"router/useRouteQuery/index.html"},{"revision":"30b27c5fb5a0b1f54f6da102a8137de4","url":"rxjs/from/index.html"},{"revision":"53d38920b008dc7c0be362e8063ba1ef","url":"rxjs/README.html"},{"revision":"8d6ab724ceb0b876494e9a9ade98630f","url":"rxjs/toObserver/index.html"},{"revision":"ed6340d2787e449cc2ecd1c5326f30a1","url":"rxjs/useExtractedObservable/index.html"},{"revision":"933660bc617d37baeaf9f6f9d6f7af01","url":"rxjs/useObservable/index.html"},{"revision":"cdcab8499d54c70826d1694aba704835","url":"rxjs/useSubject/index.html"},{"revision":"0644e427fb5c63229d6d5418991e5230","url":"rxjs/useSubscription/index.html"},{"revision":"6a602615ef599e484da0be7804825672","url":"rxjs/watchExtractedObservable/index.html"},{"revision":"8b509f83c7d624fa14120a3fd07c178d","url":"shared/computedEager/index.html"},{"revision":"3ab82b179daa55d815d53ab693117ddb","url":"shared/computedWithControl/index.html"},{"revision":"f9adc66b1a5a2095c69d93398e283b85","url":"shared/createEventHook/index.html"},{"revision":"085243cecc756c9e68fc8abd72c2dadc","url":"shared/createGlobalState/index.html"},{"revision":"b0babb3c175e8da573724a70e31aa8bb","url":"shared/createInjectionState/index.html"},{"revision":"3ff2e0b362eddb3b6993b43d20722192","url":"shared/createRef/index.html"},{"revision":"cbe4c6948dd06575d6e8f2aa2398cc51","url":"shared/createSharedComposable/index.html"},{"revision":"39ecfc2ef806c87720783c65426d3728","url":"shared/extendRef/index.html"},{"revision":"d27422224d9a7029ee9cc285b669231d","url":"shared/get/index.html"},{"revision":"ce7494dc2a6bac8044e9e59deb2f2cdd","url":"shared/injectLocal/index.html"},{"revision":"137562b2256e290ae955e0ecf07336f1","url":"shared/isDefined/index.html"},{"revision":"640e7249adabbe84a02c077f14612d13","url":"shared/makeDestructurable/index.html"},{"revision":"02743e02a5e86a27e7c4b8b4ba44c40d","url":"shared/provideLocal/index.html"},{"revision":"465e71832d9e0f57ff7909f707a93f87","url":"shared/reactify/index.html"},{"revision":"44dce2956c3bd330c204a5fe05443c51","url":"shared/reactifyObject/index.html"},{"revision":"0c4fa26f6d0aae302a3d77c73b0df697","url":"shared/reactiveComputed/index.html"},{"revision":"5dd4fa8d399bb0fdb8b4271f34feb3b3","url":"shared/reactiveOmit/index.html"},{"revision":"4c25b5c591ea7824c45f0e12f0c2f023","url":"shared/reactivePick/index.html"},{"revision":"f3f13327a9725e40e7c5c2fb03f18ef2","url":"shared/refAutoReset/index.html"},{"revision":"e265d0dbbe793d953519b41291d2b161","url":"shared/refDebounced/index.html"},{"revision":"34eca6603a7bd1988ef25a4811a56914","url":"shared/refDefault/index.html"},{"revision":"b5e80cd977cb79f54dc35c9f65f04d4c","url":"shared/refManualReset/index.html"},{"revision":"8a6b3f3422a00af87509f49ecd398697","url":"shared/refThrottled/index.html"},{"revision":"1793693c9b0fbbbc435e39ac63ae4c30","url":"shared/refWithControl/index.html"},{"revision":"9e48ad374a6160008cf1ff6a632e591d","url":"shared/set/index.html"},{"revision":"6b762b58e5129c7db21b4ca65870b8c2","url":"shared/syncRef/index.html"},{"revision":"5f02b21f60ed6875ab185dbd74112aec","url":"shared/syncRefs/index.html"},{"revision":"166d5d2114b062fb98397af4485cb0a0","url":"shared/toReactive/index.html"},{"revision":"81a817e451bcb50c68d40d823a580498","url":"shared/toRef/index.html"},{"revision":"7fb4e12534d1e55c4fa066ca1a4120d1","url":"shared/toRefs/index.html"},{"revision":"7886521e71481c7044e8594b64a3d715","url":"shared/tryOnBeforeMount/index.html"},{"revision":"eb1b52fe299a85e7636051da41849c04","url":"shared/tryOnBeforeUnmount/index.html"},{"revision":"634f96bbd6ecae65dc0909968cfbe525","url":"shared/tryOnMounted/index.html"},{"revision":"f3d341ae960b0f57981f3bc564a6674b","url":"shared/tryOnScopeDispose/index.html"},{"revision":"5bd87610d4ebe69cb50f39c50d6be001","url":"shared/tryOnUnmounted/index.html"},{"revision":"e5aabad885a170bdfd7a41f7ebab2517","url":"shared/until/index.html"},{"revision":"659270dfc056b018ab7a8c128a78ab9b","url":"shared/useArrayDifference/index.html"},{"revision":"2f876345f2579f4d15d276cd58f79f62","url":"shared/useArrayEvery/index.html"},{"revision":"1cf067411eaa34e8c7b4d32f0b7d001a","url":"shared/useArrayFilter/index.html"},{"revision":"61affd7bb987051977f0ae5e90558249","url":"shared/useArrayFind/index.html"},{"revision":"aa9b875bb9e9d951535559e06eb9ff10","url":"shared/useArrayFindIndex/index.html"},{"revision":"990693cb84ca60d8be579018cb1cd89a","url":"shared/useArrayFindLast/index.html"},{"revision":"abde1b00179cabd774ae9bc6d28ad712","url":"shared/useArrayIncludes/index.html"},{"revision":"ac9af1d930194e6ed2e8c947ee1d1d95","url":"shared/useArrayJoin/index.html"},{"revision":"542ae5a995eb429ed6e6d3e78a23f5a5","url":"shared/useArrayMap/index.html"},{"revision":"52ab2e89e8c3513e9fc1dcfd084d82eb","url":"shared/useArrayReduce/index.html"},{"revision":"55bd7f31aa4e49cc71b47632efc26a4c","url":"shared/useArraySome/index.html"},{"revision":"2bca09fcfe6da67fedf8fad8679f122d","url":"shared/useArrayUnique/index.html"},{"revision":"04550983300a9ccdec637268e039c3df","url":"shared/useCounter/index.html"},{"revision":"a0719c19e11f61914e692a487042a9b2","url":"shared/useDateFormat/index.html"},{"revision":"fc1b4573d64c0c5dcfb921fa471feb83","url":"shared/useDebounceFn/index.html"},{"revision":"112e6a5ce01547c9b7d29b97a44ce988","url":"shared/useInterval/index.html"},{"revision":"7d72492a1768a2f06686af4f66ff42f0","url":"shared/useIntervalFn/index.html"},{"revision":"75a249da32fae80f78fcfe43f7fca3c4","url":"shared/useLastChanged/index.html"},{"revision":"f55faffa9d8fbe7d9085b9811bb146a2","url":"shared/useThrottleFn/index.html"},{"revision":"1c57d2c63a5d88983c9f6dcc003daab9","url":"shared/useTimeout/index.html"},{"revision":"95f4c7cb6f795cfafcdb8dc0b40d3cf8","url":"shared/useTimeoutFn/index.html"},{"revision":"225e6597b76617ce0ec7e739fcf78415","url":"shared/useToggle/index.html"},{"revision":"d57842cff5aa2ed17f99daa90220f06d","url":"shared/useToNumber/index.html"},{"revision":"3857d535c855648adc788c942b076551","url":"shared/useToString/index.html"},{"revision":"9ab0e41c1a3f45599eeca42fc43000a3","url":"shared/watchArray/index.html"},{"revision":"55bdc3571d1325b631bdfaf7603f1522","url":"shared/watchAtMost/index.html"},{"revision":"5889edb858d3665cdcbe38a8de19d4b6","url":"shared/watchDebounced/index.html"},{"revision":"8da335bb6674f474a9cca50a936f9223","url":"shared/watchDeep/index.html"},{"revision":"e4d89ce7e2f21629f056b8b1ca7cc39d","url":"shared/watchIgnorable/index.html"},{"revision":"8bca3b57f46248310b7a9390969b29ab","url":"shared/watchImmediate/index.html"},{"revision":"0655741c77c4db78daa3c994acc36f2c","url":"shared/watchOnce/index.html"},{"revision":"6bf1348f17550273f79a49acc7a337d5","url":"shared/watchPausable/index.html"},{"revision":"3f4d279539f5e871307058f3147eb2aa","url":"shared/watchThrottled/index.html"},{"revision":"1947c4ee48d85c4b7af08c0ae346de57","url":"shared/watchTriggerable/index.html"},{"revision":"decc04cb61ae0cf9728f458860968d7a","url":"shared/watchWithFilter/index.html"},{"revision":"6ddc8cddadc97bece67fd600b6ebf65f","url":"shared/whenever/index.html"},{"revision":"f4b03737ce14d7d9eaae57a0a76dbb7d","url":"team.html"},{"revision":"ace7ab6bc932be145115857c39f7d63a","url":"vp-icons.css"},{"revision":"3d60db0d77303b2414ddd50cf2472bf7","url":"vue.png"},{"revision":"69cedcf3d2b148bdce953a480caa57b1","url":"vue.svg"},{"revision":"07025fd03ccbd8f3eda8b2f9f40f16d1","url":"why-no-translations.html"},{"revision":"6ca164689644675e74947111503fc891","url":"hashmap.json"},{"revision":"795dd8766cdee862b1f8b2a1b861ac89","url":"maskable-icon.png"},{"revision":"3d946139dd7335cd95bad54f54fb5e3e","url":"pwa-192x192.png"},{"revision":"044d2455c529e3d1872d7c2dcc0835cf","url":"pwa-512x512.png"},{"revision":"e9f21b945a4d1b3ce239cefd5a579bf3","url":"pwa-64x64.png"},{"revision":"24c269155de349f2951fbd035d5849f4","url":"manifest.webmanifest"}];
const normalizedPaths = new Map(packageNames);
const assetMatcher = /^\/assets\/([a-zA-Z]+)_([a-zA-Z]+)_index\.md\.[\w-]+\.(?:lean\.)?js$/;
const selfHostname = self.location.hostname;
precacheAndRoute(
  entries,
  {
    urlManipulation({ url }) {
      const urls = [];
      if (url.hostname !== selfHostname || url.pathname.includes(".html")) {
        return urls;
      }
      const pathname = url.pathname;
      let entry = normalizedPaths.get(pathname);
      if (!entry) {
        const match = pathname.match(assetMatcher);
        if (match) {
          const [full, pkg, name] = match;
          entry = normalizedPaths.get(`/${pkg}/${name}/`.toLowerCase());
          if (entry) {
            const newURL2 = new URL(url.href);
            newURL2.pathname = full.replace(
              `${pkg}_${name}`,
              `${entry.url.slice(1).replace(/\/$/, "").replace("/", "_")}`
            );
            urls.push(newURL2);
          }
        }
        return urls;
      }
      const newURL = new URL(url.href);
      if (newURL.hash) {
        newURL.hash = entry.hash;
      }
      newURL.pathname = `${entry.url}index.html`;
      urls.push(newURL);
      return urls;
    }
  }
);
cleanupOutdatedCaches();
let allowlist;
{
  let escapeStringRegexp = function(value) {
    return value.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  };
  const swPath = self.location.pathname.lastIndexOf("/");
  const base = swPath === 0 ? "/" : self.location.pathname.slice(0, swPath + 1);
  allowlist = entries.filter((page) => {
    return typeof page === "string" ? page.endsWith(".html") : page.url.endsWith(".html");
  }).map((page) => {
    const url = typeof page === "string" ? page : page.url;
    const regex = url === "index.html" ? escapeStringRegexp(base) : escapeStringRegexp(`${base}${url.replace(/\.html$/, "")}`);
    return new RegExp(`^${regex}(\\.html)?$`);
  });
  registerRoute(
    ({ request, sameOrigin }) => {
      return sameOrigin && request.mode === "navigate";
    },
    new NetworkOnly({
      plugins: [{
        /* this callback will be called when the fetch call fails */
        handlerDidError: async () => Response.redirect("404", 302),
        /* this callback will prevent caching the response */
        cacheWillUpdate: async () => null
      }]
    }),
    "GET"
  );
  registerRoute(
    /^https:\/\/fonts\.googleapis\.com\/.*/i,
    new NetworkFirst({
      cacheName: "google-fonts-cache",
      plugins: [
        new CacheableResponsePlugin({ statuses: [0, 200] }),
        // we only need a few entries
        new ExpirationPlugin({
          maxEntries: 10,
          maxAgeSeconds: 60 * 60 * 24 * 365
          // <== 365 days
        })
      ]
    })
  );
  registerRoute(
    /^https:\/\/fonts\.gstatic\.com\/.*/i,
    new StaleWhileRevalidate({
      cacheName: "google-fonts-cache",
      plugins: [
        new CacheableResponsePlugin({ statuses: [0, 200] }),
        // we only need a few entries
        new ExpirationPlugin({
          maxEntries: 10,
          maxAgeSeconds: 60 * 60 * 24 * 365
          // <== 365 days
        })
      ]
    })
  );
  registerRoute(
    /^https:\/\/cdn\.jsdelivr\.net\/.*/i,
    new NetworkFirst({
      cacheName: "jsdelivr-images-cache",
      plugins: [
        new CacheableResponsePlugin({ statuses: [0, 200] }),
        // we only need a few entries
        new ExpirationPlugin({
          maxEntries: 10,
          maxAgeSeconds: 60 * 60 * 24 * 7
          // <== 7 days
        })
      ]
    })
  );
}
registerRoute(new NavigationRoute(
  createHandlerBoundToURL("index.html"),
  { allowlist }
));
self.addEventListener("activate", async () => {
  const clients = await self.clients.matchAll({ type: "window" });
  clients.forEach((client) => {
    client.navigate(client.url);
  });
});
self.skipWaiting();
